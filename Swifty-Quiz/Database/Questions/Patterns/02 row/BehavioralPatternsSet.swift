
//  Created by Евгений Никитин on 25.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

// MARK:  Вопросы (id) с 2701 по 2800

class BehavioralPatternsSet {
    static func getQuestions() -> [Question] {
        return [
            
            Question(question: ["Что является основой поведенческих паттернов?"],
                     image: "",
                     optionA: "Управление поведением",
                     optionB: "Создание объектов",
                     optionC: "Структурирование кода",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 2504,
                     helpText: "Поведенческие паттерны являются самой большой категорией, сюда входят все паттерны, которые так или иначе определяют поведение объектов и их взаимодействие друг с другом."),
            
            Question(question: ["Паттерн, который определяет семейство объектов, каждый из которых реализует один и тот же интерфейс разными алгоритмами",
                                "Паттерн, который позволяет при одних и тех же действиях юзера, но разных условиях использовать разную реализацию",
                                "Какой паттерн позволяет при одних действиях юзера, но разных условиях, использовать разную реализацию?"],
                     image: "",
                     optionA: "Strategy",
                     optionB: "Delegate",
                     optionC: "Facade",
                     optionD: "Observer",
                     correctAnswer: 1,
                     questionId: 2509,
                     helpText: "Паттерн Strategy (стратегия) — поведенческий шаблон проектирования. Он определяет семейство объектов, каждый из которых реализует один и тот же интерфейс разными алгоритмами. В рантайме объекты могут заменяться друг на друга, что позволяет при одних и тех же действиях юзера, но разных условиях использовать разную реализацию."),
            
            Question(question: ["Какой паттерн помогает одним объектам узнавать об изменении других?",
                                "Этот поведенческий паттерн помогает одним объектам узнавать об изменении других",
                                "Этот поведенческий шаблон проектирования помогает одним объектам узнавать об изменении других"],
                     image: "",
                     optionA: "Observer",
                     optionB: "Adapter",
                     optionC: "Delegate",
                     optionD: "Proxy",
                     correctAnswer: 1,
                     questionId: 2521,
                     helpText: "Паттерн Observer (наблюдатель) — поведенческий шаблон проектирования. Он используется, когда одни объекты должны узнавать об изменениях состояния других."),
            
            Question(question: ["Паттерн, который позволяет выбрать путь, которым мы получим результат",
                                "Какой паттерн позволяет выбрать путь, которым мы получим итоговый результат?"],
                     image: "",
                     optionA: "Strategy",
                     optionB: "Memento",
                     optionC: "Facade",
                     optionD: "Observer",
                     correctAnswer: 1,
                     questionId: 2512,
                     helpText: "Cтратегия (Strategy) позволяет выбрать путь, которым мы получим результат. Паттерн очень прост в использовании и практически не имеет минусов. Единственный недостаток — нужно создавать дополнительные классы и сущности, но это свойственно большинству паттернов проектирования."),
            
            Question(question: ["Во время реализации паттерна Сратегия, желательно ли создавать разные файлы для каждой стратегии?",
                                "При реализации паттерна Стратегия (Strategy) желательно создавать новый файл для каждой стратегии, так ли это?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 2515,
                     helpText: "На каждую стратегию желательно создавать отдельный файл с кодом."),
            
            Question(question: ["Cамый простой, но наименее желательный способ реализации паттерна Observer?",
                                "Спобоб реализации паттерна Observer, который нарушает абстракцию, усложняет код для чтения и поддержки?",
                                "Самый простой, но наименее желательный способ реализации паттерна Observer, который усложняет код для чтения и поддержки"],
                     image: "",
                     optionA: "NotificationCenter",
                     optionB: "KVO (key-value observing)",
                     optionC: "RxSwift",
                     optionD: "Собственная обертка",
                     correctAnswer: 1,
                     questionId: 2522,
                     helpText: "NotificationCenter. Это самый простой, но наименее желательный способ реализации. Дело в том, что он нарушает абстракцию, усложняет код для чтения и поддержки. Частично вы с ним должны быть уже знакомы из предыдущих курсов."),
            
            Question(question: ["Механизм для реализации паттерна Observer, пришедший из Objective-C?",
                                "Реализация паттерна Observer, которая использует objc-runtime, поэтому нам нужно помечать классы и свойства маркером @objc, а классы наследовать от NSObject",
                                "Механизм для реализации паттерна Observer, пришедший из Objective-C, который на чистом Swift используется крайне редко"],
                     image: "",
                     optionA: "KVO (key-value observing)",
                     optionB: "NotificationCenter",
                     optionC: "RxSwift",
                     optionD: "Собственная обертка",
                     correctAnswer: 1,
                     questionId: 2525,
                     helpText: "KVO (key-value observing). Это механизм для реализации observer, пришедший из Objective-C. KVO использует objc-runtime, поэтому нам нужно помечать классы и свойства маркером @objc, а классы наследовать от NSObject. При разработке на чистом Swift используется крайне редко (да и на Objective-C, как правило, для специфических задач)."),
            
            Question(question: ["Паттерн, который используется для того, чтобы при работе с объектом была возможность его сохранить и впоследствии восстановить",
                                "Какой шаблон проектирования используется для того, чтобы при работе с объектом была возможность его сохранить и впоследствии восстановить?"],
                     image: "",
                     optionA: "Memento",
                     optionB: "Observer",
                     optionC: "State",
                     optionD: "Strategy",
                     correctAnswer: 1,
                     questionId: 2530,
                     helpText: "Паттерн Memento. Этот паттерн (в переводе — хранитель) используется для того, чтобы при работе с объектом была возможность его сохранить и впоследствии восстановить. Чаще всего нужно сохранять состояние приложения в определенный момент — например, чтобы после завершения программы и повторного открытия начать с предыдущего состояния. Если в программе есть фича undo/redo (отменить изменения и вернуть изменения), то можно использовать массив хранителей, чтобы восстанавливать все предыдущие состояния."),
            
            Question(question: ["Поведенческий шаблон проектирования, который позволяет несовместимым интерфейсам работать вместе",
                                "Паттерн, который не реализует функциональность, а лишь использует уже написанную (позволяет несовместимым интерфейсам работать вместе)",
                                "Какой шаблон проектирования позволяет несовместимым интерфейсам работать вместе, а так же использует уже написанную функциональность?"],
                     image: "",
                     optionA: "Adapter",
                     optionB: "Singleton",
                     optionC: "Visitor",
                     optionD: "Flyweight",
                     correctAnswer: 1,
                     questionId: 2531,
                     helpText: "Паттерн Adapter (адаптер) — поведенческий шаблон проектирования. Он позволяет несовместимым интерфейсам работать вместе. Представьте, что у вас есть код, который вы или не можете менять (например, он находится внутри закрытого фреймворка), или очень не хотите этого делать. Но использовать его трудно и хочется обращаться к нему через совсем другой интерфейс. В этом случае вы создаете такой интерфейс (в виде протокола), затем пишете объект-адаптер. Он будет поддерживать этот протокол. Таким образом, обращаясь к адаптеру, вы используете тот интерфейс, который хотели. Но сам адаптер не реализует функциональность, а лишь использует уже написанную."),
            
            Question(question: ["При использовании какого паттерна мы создаем Originator и Caretaker?",
                                "Originator и Caretaker создаются при использовании этого паттерна",
                                "В каком паттерне используются Originator и Caretaker?"],
                     image: "",
                     optionA: "Memento",
                     optionB: "State",
                     optionC: "Builder",
                     optionD: "Factory",
                     correctAnswer: 1,
                     questionId: 2534,
                     helpText: "В паттерне Memento есть три участника: 1. Originator — объект, который требуется сохранить и впоследствии восстановить. 2. Memento — сохраненные данные. При сохранении Originator эндкодится в Memento, при восстановлении Memento декодится в Originator. Caretaker — объект, который занимается сохранением и восстановлением."),
            
            Question(question: ["Вы решаете улучшить приложение, применив стороннюю библиотеку. Но библиотека поддерживает только формат JSON, несовместимый с вашим приложением. Какой паттерн можно применить?"],
                     image: "",
                     optionA: "Adapter",
                     optionB: "Delegate",
                     optionC: "State",
                     optionD: "Prototype",
                     correctAnswer: 1,
                     questionId: 2536,
                     helpText: "В какой-то момент вы решаете улучшить приложение, применив стороннюю библиотеку аналитики. Но вот беда — библиотека поддерживает только формат данных JSON, несовместимый с вашим приложением. Вы смогли бы переписать библиотеку, чтобы та поддерживала формат XML. Но, во-первых, это может нарушить работу существующего кода, который уже зависит от библиотеки. А во-вторых, у вас может просто не быть доступа к её исходному коду. Вы можете создать Adapter. Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту."),
            
            Question(question: ["Какой паттерн для своей работы использует JSONEncoder и JSONDecoder?",
                                "Этот паттерн, для сохранения и загрузки из памяти телефона, использует JSONEncoder и JSONDecoder",
                                "JSONEncoder и JSONDecoder используются при реализации этого паттерна"],
                     image: "",
                     optionA: "Memento",
                     optionB: "State",
                     optionC: "Builder",
                     optionD: "Factory",
                     correctAnswer: 1,
                     questionId: 2535,
                     helpText: "При сохранении игры Memento использует JSONEncoder и сохраняет полученные данные в UserDefaults. Для загрузки он берет данные из UserDefaults и с помощью JSONDecoder превращает их в объект. Если что-то не получилось, то выбрасываем из функции ошибку."),
            
            Question(question: ["Поведенческий паттерн проектирования, который позволяет сохранять и восстанавливать прошлые состояния объектов",
                                "Паттерн проектирования, который позволяет сохранять и восстанавливать прошлые состояния объектов, не раскрывая подробностей их реализации?",
                                "Паттерн, который позволяет сохранять и загружать при необходимости разные состояния объектов"],
                     image: "",
                     optionA: "Memento",
                     optionB: "State",
                     optionC: "Builder",
                     optionD: "Factory",
                     correctAnswer: 1,
                     questionId: 2542,
                     helpText: "Memento — это поведенческий паттерн проектирования, который позволяет сохранять и восстанавливать прошлые состояния объектов, не раскрывая подробностей их реализации."),
            
            Question(question: ["Поведенческий шаблон проектирования, который предназначен для распределения обработки сообщения / события между разными объектами.",
                                "Какой паттерн предназначен для распределения обработки сообщения / события между разными объектами?",
                                "У какого поведенческого шаблона проектирования следующая структура: сначала один объект пытается обработать событие; если он не может этого сделать, то посылает его следующему обработчику?"],
                     image: "",
                     optionA: "Chain of Responsibility",
                     optionB: "Strategy",
                     optionC: "Visitor",
                     optionD: "Observer",
                     correctAnswer: 1,
                     questionId: 2606,
                     helpText: "Паттерн Chain of Responsibility (цепочка обязанностей) — поведенческий шаблон проектирования. Он предназначен для распределения обработки сообщения / события между разными объектами. Структура паттерна следующая: сначала один объект пытается обработать событие; если он не может этого сделать, то посылает его следующему обработчику. Все обработчики выстроены в последовательную цепочку и реализуют один протокол."),
            
            Question(question: ["В какой-то момент вы решили сделать все действия в своем приложении отменяемыми. Для этого вам нужно сохранять текущее состояние перед тем, как выполнить любое действие. Какой паттерн использовать?",
                                "Вы решили сделать действия в своем приложении отменяемыми. Для этого вам нужно сохранять состояние приложения перед тем, как выполнить любое действие. Какой паттерн будете использовать?"],
                     image: "",
                     optionA: "Memento",
                     optionB: "State",
                     optionC: "Builder",
                     optionD: "Factory",
                     correctAnswer: 1,
                     questionId: 2543,
                     helpText: "Вам поможет паттерн Memento."),
            
            Question(question: ["Поведенческий шаблон проектирования, в котором центральную роль играют команды, становящиеся отдельными объектами (то, что должно быть выполнено, но через какое-то время)",
                                "В каком паттерне проектирования центральную роль играют команды, где объект команды — это то, что должно быть выполнено, но обычно через какое-то время?",
                                "Паттерн проектирования, в котором главный объект - команда, которая должна выполняться, но не сразу. Так же эти команды до выполнения хранятся в памяти и даже могут изменяться."],
                     image: "",
                     optionA: "Command",
                     optionB: "Composite",
                     optionC: "Chain Of Responsibility",
                     optionD: "Mediator",
                     correctAnswer: 1,
                     questionId: 2607,
                     helpText: "Паттерн Command (команда) — поведенческий шаблон проектирования. В этом паттерне центральную роль играют команды, которые становятся отдельными объектами. Объект команды — это то, что должно быть выполнено, но обычно через какое-то время. До этого момента объект команды хранится в памяти и даже может изменяться. Паттерн «команда» служит для того, чтобы описать и сохранить действие, которое должно быть выполнено позже."),
            
            Question(question: ["Паттерн, который применяется в системе, где есть много взаимодействующих друг с другом объектов, чтобы уменьшить связность между ними",
                                "Какой поведенческий шаблон проектирования применяется в системе, где есть много взаимодействующих друг с другом объектов, чтобы уменьшить связность между ними?",
                                "В каком паттерне проектирования объект взаимодействует с другим объектом не напрямую, а через посредника, который передает это взаимодействие всем другим объектам?"],
                     image: "",
                     optionA: "Mediator",
                     optionB: "Proxy",
                     optionC: "Memento",
                     optionD: "Delegate",
                     correctAnswer: 1,
                     questionId: 2608,
                     helpText: "Паттерн Mediator (посредник) — поведенческий шаблон проектирования. Он применяется в системе, где есть много взаимодействующих друг с другом объектов, чтобы уменьшить связность между ними. Объект взаимодействует не с другими напрямую, а с посредником, который уже передает это взаимодействие всем другим объектам. "),
            
            Question(question: ["Суть этого паттерна заключается в том, что в зависимости от состояния отображается разная информация, и нажатие обрабатывается по-своему"],
                     image: "",
                     optionA: "State",
                     optionB: "Prototype",
                     optionC: "Command",
                     optionD: "Mediator",
                     correctAnswer: 1,
                     questionId: 2609,
                     helpText: "В зависимости от состояния отображается разная информация, и нажатие обрабатывается по-своему. В этом суть паттерна State."),
            
            Question(question: ["В чем отличие паттерна State от паттерна Strategy?",
                                "Шаблон проектирования State отличается от шаблона Strategy этим",
                                "Чем отличается паттерн проектирования State от Strategy?"],
                     image: "",
                     optionA: "State затрагивает UI и логику",
                     optionB: "Только в названии",
                     optionC: "State не затрагивает логику",
                     optionD: "Strategy изменяет UI приложения",
                     correctAnswer: 1,
                     questionId: 2610,
                     helpText: "Отличие состоит в том, что состояние хранится приложением, и обязательно произойдет переход из одного состояния в другое. Также в стратегии, как правило, наша цель — не вдаваясь в реализацию, выполнить одно действие и получить результат. Состояние же влияет на множество компонентов — в нашем примере и на UI-приложения, и на логику работы."),
            
            Question(question: ["Допустим у нас есть ход первого игрока, ход второго игрока, и состояние завершения игры. Какой паттерн мы можем применить, чтобы управлять этими состояниями в нашем приложении?",
                                "Если в вашем приложении есть разные состояния, с помощью какого паттерна мы можем ими управлять через один общий интерфейс?"],
                     image: "",
                     optionA: "State",
                     optionB: "Proxy",
                     optionC: "Memento",
                     optionD: "Delegate",
                     correctAnswer: 1,
                     questionId: 2611,
                     helpText: "Правильный ответ: State"),
            
            Question(question: ["Структура какого паттерна состоит из трех объектов, Invoker -> Command -> Receiver?",
                                "Invoker -> Command -> Receiver является структурой этого паттерна",
                                "Какой паттерн проектирования имеет структуру, состоящую их трех объектов: Invoker, Command, Receiver?"],
                     image: "",
                     optionA: "Command",
                     optionB: "Receiver",
                     optionC: "Factory",
                     optionD: "Abstract Invoker",
                     correctAnswer: 1,
                     questionId: 2613,
                     helpText: "Рассмотрим структуру паттерна Command. Она состоит из трех объектов: Invoker -> Command -> Receiver. Invoker («вызывающий») — объект, который хранит команды и ставит их на исполнение. Это контроллер для команд. Command — непосредственно объект команды. Он инкапсулирует действие, которое должно быть выполнено позднее. Receiver («получатель») — объект, который получает команды. Именно он делает всю основную работу. Он получает команды, но они содержат лишь описание действия. Само действие делает receiver."),
            
            Question(question: ["Поведенческий шаблон проектирования, который работает с состоянием объекта.",
                                "Какой поведенческий шаблон проектирования работает с состоянием объекта?",
                                "Этот поведенческий паттерн работает с состоянием объекта"],
                     image: "",
                     optionA: "State",
                     optionB: "Prototype",
                     optionC: "Command",
                     optionD: "Mediator",
                     correctAnswer: 1,
                     questionId: 2601,
                     helpText: "Паттерн State (состояние) — поведенческий шаблон проектирования. По его названию понятно, что этот паттерн работает с состояниями объекта. Их может быть несколько, и в зависимости от них будет реализовываться поведение."),
            
            Question(question: ["Какой паттерн позволяет реализовать логирование (запись действий приложения в лог)?",
                                "Этот шаблон позволяет записывать действия приложения в лог, отдельный файл, который можно хранить на клиенте и при необходимости достать, чтобы отправить на сервер (например для крэш-аналитики)",
                                "Какой паттерн проектирования позволяет накапливать логи в отдельном классе, чтобы потом, когда накопится достаточное количество - сохранять их в файл?"],
                     image: "",
                     optionA: "Command",
                     optionB: "Receiver",
                     optionC: "Factory",
                     optionD: "Invoker",
                     correctAnswer: 1,
                     questionId: 2614,
                     helpText: "Логирование. Это запись действий приложения в лог — отдельный файл, который можно хранить на клиенте и при необходимости достать, чтобы отправить на сервер (а там уже разработчики будут смотреть логи и выяснять, что привело к ошибке в приложении). Запись большого количества текста в файл — не самая дешевая операция, и делать ее на каждый чих приложения затратно. Поэтому лучше складировать команды на запись логов в отдельном классе (роль invoker), а затем, когда логов накопится достаточно много (или приложение вот-вот выгрузится из памяти), все накопленные записи разом сохранить в файл."),
            
            Question(question: ["Паттерн, в котором помимо еще одного объекта есть объект colleague",
                                "Паттерн, в котором объект colleague должен взаимодействовать с другими такими же объектами через посредника",
                                "В этом шаблоне проектирования одному объекту colleague запрещено обращаться напрямую к другим таким же объектам, в обход посредника"],
                     image: "",
                     optionA: "Mediator",
                     optionB: "Chain of Responsibility",
                     optionC: "Colleague",
                     optionD: "Proxy",
                     correctAnswer: 1,
                     questionId: 2617,
                     helpText: "Классический вариант использования паттерна Mediator. По структуре: в паттерне два действующих лица — mediator и colleague. Оба представлены своим протоколом и соответствующими конкретными реализациями. Colleague — объект, который хочет взаимодействовать с другими такими же объектами. Он должен делать это через посредника mediator. Прямые обращения одного colleague к другому запрещены."),
            
            Question(question: ["Какой паттерн невозможно рассматривать в отрыве от концепции машины состояний?",
                                "Этот шаблон проектирования невозможно рассматривать в отрыве от концепции \"конечный автомат\""],
                     image: "",
                     optionA: "State",
                     optionB: "Prototype",
                     optionC: "Decorator",
                     optionD: "Visitor",
                     correctAnswer: 1,
                     questionId: 2627,
                     helpText: "Паттерн Состояние (State) невозможно рассматривать в отрыве от концепции машины состояний, также известной как стейт-машина или конечный автомат. Основная идея в том, что программа может находиться в одном из нескольких состояний, которые всё время сменяют друг друга. Набор этих состояний, а также переходов между ними, предопределён и конечен. Находясь в разных состояниях, программа может по-разному реагировать на одни и те же события, которые происходят с ней."),
            
            Question(question: ["Какому паттерну присущи следующие плюсы: избавляет от множества больших условных операторов машины состояний, концентрирует в одном месте код, связанный с определённым состоянием?",
                                "К какому паттерну относятся эти плюсы: концентрирует в одном месте код, связанный с определённым состоянием, упрощает код контекста?",
                                "Какой паттерн может неоправданно усложнить код, если состояний мало и они редко меняются?"],
                     image: "",
                     optionA: "State",
                     optionB: "Prototype",
                     optionC: "Delegate",
                     optionD: "Decorator",
                     correctAnswer: 1,
                     questionId: 2628,
                     helpText: "Преимущества и недостатки паттерна State (состояние): Избавляет от множества больших условных операторов машины состояний. Концентрирует в одном месте код, связанный с определённым состоянием. Упрощает код контекста. Может неоправданно усложнить код, если состояний мало и они редко меняются."),
            
            Question(question: ["Какому паттерну присущи данные преимущества: убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно выполняют, позволяет реализовать простую отмену и повтор операций?",
                                "К какому паттерну относятся данные преимущества: позволяет реализовать отложенный запуск операций, позволяет собирать сложные команды из простых, реализует принцип открытости/закрытости?"],
                     image: "",
                     optionA: "Command",
                     optionB: "Composite",
                     optionC: "Chain of Responsibility",
                     optionD: "Mediator",
                     correctAnswer: 1,
                     questionId: 2631,
                     helpText: "Преимущества и недостатки паттерна Command (команда): Убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно выполняют. Позволяет реализовать простую отмену и повтор операций. Позволяет реализовать отложенный запуск операций. Позволяет собирать сложные команды из простых. Реализует принцип открытости/закрытости. Усложняет код программы из-за введения множества дополнительных классов."),
            
            Question(question: ["Какому паттерну присущи данные преимущества: уменьшает зависимость между клиентом и обработчиками, реализует принцип единственной обязанности, реализует принцип открытости/закрытости?",
                                "К какому поведенческому паттерну относится данный недостаток: Запрос может остаться никем не обработанным?"],
                     image: "",
                     optionA: "Chain of Responsibility",
                     optionB: "Adapter",
                     optionC: "Bridge",
                     optionD: "Composite",
                     correctAnswer: 1,
                     questionId: 2635,
                     helpText: "Преимущества и недостатки паттерна Chain of Responsibility (цепочка обязанностей): Уменьшает зависимость между клиентом и обработчиками. Реализует принцип единственной обязанности. Реализует принцип открытости/закрытости. Запрос может остаться никем не обработанным."),
            
            Question(question: ["Какому паттерну присущи данные преимущества: устраняет зависимости между компонентами, позволяя повторно их использовать, упрощает взаимодействие между компонентами, централизует управление в одном месте?",
                                "К какому паттерну относится данный недостаток: Посредник может сильно раздуться?"],
                     image: "",
                     optionA: "Mediator",
                     optionB: "Abstract Factory",
                     optionC: "Builder",
                     optionD: "Prototype",
                     correctAnswer: 1,
                     questionId: 2636,
                     helpText: "Преимущества и недостатки паттерна Mediator (посредник): Устраняет зависимости между компонентами, позволяя повторно их использовать. Упрощает взаимодействие между компонентами. Централизует управление в одном месте. Посредник может сильно раздуться."),
        ]
    }
}
