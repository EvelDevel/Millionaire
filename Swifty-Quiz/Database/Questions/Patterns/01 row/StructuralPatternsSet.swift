
//  Created by Евгений Никитин on 25.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

// MARK:  Вопросы (id) с 2601 по 2700

class StructuralPatternsSet {
    static func getQuestions() -> [Question] {
        return [
            Question(question: ["Что лежит в основе структурных паттернов?"],
                     image: "",
                     optionA: "Структурирование кода",
                     optionB: "Управление поведением",
                     optionC: "Создание объектов",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 2503,
                     helpText: "Структурные паттерны позволяют лучше структурировать код, чтобы его было легче понимать."),
            
            Question(question: ["Целью какого паттерна является минимизация используемой памяти там, где необязательно создавать несколько объектов, а вместо этого можно переиспользовать один?",
                                "Структурный паттерн, целью которого является минимизация используемой памяти там, где необязательно создавать несколько объектов, а можно переиспользовать один",
                                "Какой паттерн позволяет переиспользовать один объект, чтобы не создавать новые?"],
                     image: "",
                     optionA: "Flyweight",
                     optionB: "Delegate",
                     optionC: "Adapter",
                     optionD: "Abstract Factory",
                     correctAnswer: 1,
                     questionId: 2510,
                     helpText: "Паттерн flyweight — «легковес». В переводах классических книг он обычно называется «приспособленец». По классификации это структурный паттерн. Его цель — в минимизации используемой памяти там, где необязательно создавать несколько объектов, а вместо этого можно переиспользовать один."),
            
            Question(question: ["Структурный шаблон, который берет сложную систему и упрощает ее, предоставляя простой интерфейс",
                                "Паттерн, который упрощает сложную систему, предоставляя простой интерфейс",
                                "Этот структурный паттерн преодоставляет простой интерфейс от упрощенной сложной системы"],
                     image: "",
                     optionA: "Facade (Фасад)",
                     optionB: "Memento (Хранитель)",
                     optionC: "Delegate (Делегат)",
                     optionD: "Observer (Наблюдатель)",
                     correctAnswer: 1,
                     questionId: 2516,
                     helpText: "Паттерн Facade (фасад) — структурный шаблон проектирования. Он упрощает сложную систему, предоставляя простой интерфейс."),
            
            Question(question: ["Есть ли у паттерна Facade (Фасад) строгие предписания того, как его реализовывать?",
                                "У паттерна Facade (Фасад) есть жесткие предписания того, какие методы должны использоваться при его реализации?",
                                "Чтобы максимально удобно структурировать работу нескольких сложных систем используется паттерн Facade (Фасад), есть ли у него строгие предписания по реализации?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 2518,
                     helpText: "У паттерна Facade (Фасад) паттерна нет строгих предписаний о том, как реализовывать фасад, какие у него должны быть методы. К каждой задаче фасад делается так, чтобы максимально удобно структурировать сложную работу нескольких систем."),
            
            Question(question: ["Назовите паттерн, чьим принципом является следующее: вместо создания и хранения в памяти нескольких объектов, мы создаем и храним один объект и используем его для всех случаев",
                                "Создание одного объекта и использование его для всех необходимых случаев, является принципом данного паттерна"],
                     image: "",
                     optionA: "Flyweight",
                     optionB: "Delegate",
                     optionC: "Adapter",
                     optionD: "Abstract Factory",
                     correctAnswer: 1,
                     questionId: 2519,
                     helpText: "Flyweight: вместо создания и хранения в памяти нескольких объектов, нужных для одной цели, мы создаем и храним один объект и используем его для всех случаев. Все стандартные цвета, такие как UIColor.red, UIColor.green, UIColor.white, UIColor.black и т. д. реализованы по паттерну flyweight."),
            
            Question(question: ["Можем ли мы использовать Фасад (Facade) как объект одиночку (Singleton)?",
                                "Можно ли использовать паттерн Facade как класс-одиночку (Singleton)?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 2541,
                     helpText: "Фасад можно сделать Одиночкой, так как обычно нужен только один объект-фасад."),
            
            Question(question: ["Какому паттерну присущи следующие преимущества: позволяет контролировать сервисный объект незаметно для клиента, может работать, даже если сервисный объект ещё не создан?",
                                "К какому паттерну относятся данные преимущества: может работать, даже если сервисный объект ещё не создан, может контролировать жизненный цикл служебного объекта?"],
                     image: "",
                     optionA: "Proxy",
                     optionB: "Decorator",
                     optionC: "Composite",
                     optionD: "Mediator",
                     correctAnswer: 1,
                     questionId: 2633,
                     helpText: "Преимущества и недостатки паттерна Proxy (прокси, заместитель): Позволяет контролировать сервисный объект незаметно для клиента. Может работать, даже если сервисный объект ещё не создан. Может контролировать жизненный цикл служебного объекта. Усложняет код программы из-за введения дополнительных классов. Увеличивает время отклика от сервиса."),
            
            Question(question: ["Дизайнер придумал для вашего приложения цветовую палитру, с помощью какого паттерна ее логичнее всего хранить и использовать?",
                                "Каким паттерном логичнее всего пользоваться, если вам нужно хранить и использовать цветовую палитру, которая будет использоваться для вашего приложения?",
                                "Дизайнер придумал для вашего приложения палитру брендовых цветов, какой паттерн логичнее всего применить для хранения этих цветов, и их использования?"],
                     image: "",
                     optionA: "Flyweight",
                     optionB: "Delegate",
                     optionC: "Adapter",
                     optionD: "Abstract Factory",
                     correctAnswer: 1,
                     questionId: 2520,
                     helpText: "В любом приложении под iOS используются цвета. Как правило, дизайнер придумывает палитру из оттенков, наиболее часто используемых в дизайне приложения, а в коде хранятся переменные, которые эту палитру описывают. Самым логичным решением будет хранить эти переменные, используя паттерн flyweight, который в Swift реализуется очень просто."),
            
            Question(question: ["Cтруктурный шаблон проектирования, расширяющий функциональность объекта без использования наследования",
                                "Какой структурный шаблон проектирования расширяет функциональность объекта без использования наследования?",
                                "Этот паттерн, без использования наследования расширяет функциональность объекта"],
                     image: "",
                     optionA: "Decorator",
                     optionB: "Chain Of Responsibility",
                     optionC: "Mediator",
                     optionD: "Command",
                     correctAnswer: 1,
                     questionId: 2602,
                     helpText: "Decorator (декоратор) — структурный шаблон проектирования, расширяющий функциональность объекта без использования наследования."),
            
            Question(question: ["Этот структурный шаблон проектирования представляет объекты в виде древовидной структуры и обеспечивает к ним доступ через единый интерфейс",
                                "Какой структурный паттерн представляет объекты в виде древовидной структуры?",
                                "Какой паттерн проектирования обеспечивает доступ к древовидной структуре объектов через единый интерфейс?"],
                     image: "",
                     optionA: "Composite",
                     optionB: "Chain Of Responsibility",
                     optionC: "Mediator",
                     optionD: "Command",
                     correctAnswer: 1,
                     questionId: 2603,
                     helpText: "Паттерн Composite (компоновщик) — структурный шаблон проектирования. Он представляет объекты в виде древовидной структуры и обеспечивает к ним доступ через единый интерфейс."),
            
            Question(question: ["Cтруктурный шаблон проектирования, который представляет собой объект, контролирующий доступ к другому объекту, перехватывая все вызовы.",
                                "Какой паттерн представляет собой объект, контролирующий доступ к другому объекту, перехватывая все вызовы?",
                                "Этот стркутурный шаблон проектирования представляет собой объект, контролирующий доступ к другому объекту, перехватывая все вызовы"],
                     image: "",
                     optionA: "Proxy",
                     optionB: "Adapter",
                     optionC: "Bridge",
                     optionD: "Facade",
                     correctAnswer: 1,
                     questionId: 2605,
                     helpText: "Паттерн Proxy (прокси, «заместитель») — структурный шаблон проектирования. Представляет собой объект, который контролирует доступ к другому объекту, перехватывая все вызовы. При этом объект-прокси имеет тот же интерфейс, что и настоящий объект."),
            
            Question(question: ["У какого паттерна мы можем наблюдать подобную древовидную структуру?",
                                "Какой паттерн обладает такой же древовидной структурой?"],
                     image: "StructuralPatterns1",
                     optionA: "Composite",
                     optionB: "Component",
                     optionC: "Delegate",
                     optionD: "Factory",
                     correctAnswer: 1,
                     questionId: 2615,
                     helpText: "Подобная структура у паттерна Composite. Рассмотрим схему этого паттерна. Может быть сколько угодно классов, которые реализуют протокол, но их можно разделить на две части: композитные объекты и \"листья\". Композитные объекты (folder) содержат другие объекты, обычно в виде массива. Листья (файлы) не содержат других компонентов — так что являются конечными объектами в структуре."),
            
            Question(question: ["Какому паттерну присущи следующие преимущества: большая гибкость, чем у наследования, позволяет добавлять обязанности на лету, можно добавлять несколько новых обязанностей сразу?",
                                "К какому паттерну относится это преимущество: позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни, большая гибкость, чем у наследования?",
                                "У какого паттерна большая гибкость, чем у наследования, но есть недостатки в виде трудностей конфигурирования многократно обёрнутых объектов и обилия крошечных классов?"],
                     image: "",
                     optionA: "Decorator",
                     optionB: "Proxy",
                     optionC: "Composite",
                     optionD: "Mediator",
                     correctAnswer: 1,
                     questionId: 2632,
                     helpText: "Преимущества и недостатки паттерна Decorator (декоратор): Большая гибкость, чем у наследования. Позволяет добавлять обязанности на лету. Можно добавлять несколько новых обязанностей сразу. Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни. Трудно конфигурировать многократно обёрнутые объекты. Обилие крошечных классов."),
            
            Question(question: ["Какому паттерну присущи данные преимущества: упрощает архитектуру клиента при работе со сложным деревом компонентов, облегчает добавление новых видов компонентов?",
                                "К какому паттерну относится данный недостаток: создаёт слишком общий дизайн классов?"],
                     image: "",
                     optionA: "Composite",
                     optionB: "Delegate",
                     optionC: "Factory",
                     optionD: "Flyweight",
                     correctAnswer: 1,
                     questionId: 2634,
                     helpText: "Преимущества и недостатки паттерна Composite (компоновщик): Упрощает архитектуру клиента при работе со сложным деревом компонентов. Облегчает добавление новых видов компонентов. Создаёт слишком общий дизайн классов."),
            
        ]
    }
}
