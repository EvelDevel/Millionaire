
//  Created by Евгений Никитин on 25.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

// MARK:  Вопросы (id) с 2601 по 2700

/// В этом файле вопросы по следующим паттернам:
/// - state, prototype, command, decorator, proxy
/// - composite, chain of responsibility, mediator

class AdvancedPatternsSet {
    static func getQuestions() -> [Question] {
        return [
            Question(question: ["Поведенческий шаблон проектирования, который работает с состоянием объекта.",
                                "Какой поведенческий шаблон проектирования работает с состоянием объекта?",
                                "Этот поведенческий паттерн работает с состоянием объекта"],
                     image: "",
                     optionA: "State",
                     optionB: "Prototype",
                     optionC: "Command",
                     optionD: "Mediator",
                     correctAnswer: 1,
                     questionId: 2601,
                     helpText: "Паттерн State (состояние) — поведенческий шаблон проектирования. По его названию понятно, что этот паттерн работает с состояниями объекта. Их может быть несколько, и в зависимости от них будет реализовываться поведение."),
            
            Question(question: ["Cтруктурный шаблон проектирования, расширяющий функциональность объекта без использования наследования",
                                "Какой структурный шаблон проектирования расширяет функциональность объекта без использования наследования?",
                                "Этот паттерн, без использования наследования расширяет функциональность объекта"],
                     image: "",
                     optionA: "Decorator",
                     optionB: "Chain Of Responsibility",
                     optionC: "Mediator",
                     optionD: "Command",
                     correctAnswer: 1,
                     questionId: 2602,
                     helpText: "Decorator (декоратор) — структурный шаблон проектирования, расширяющий функциональность объекта без использования наследования."),
            
            Question(question: ["Этот структурный шаблон проектирования представляет объекты в виде древовидной структуры и обеспечивает к ним доступ через единый интерфейс",
                                "Какой структурный паттерн представляет объекты в виде древовидной структуры?",
                                "Какой паттерн проектирования обеспечивает доступ к древовидной структуре объектов через единый интерфейс?"],
                     image: "",
                     optionA: "Composite",
                     optionB: "Chain Of Responsibility",
                     optionC: "Mediator",
                     optionD: "Command",
                     correctAnswer: 1,
                     questionId: 2603,
                     helpText: "Паттерн Composite (компоновщик) — структурный шаблон проектирования. Он представляет объекты в виде древовидной структуры и обеспечивает к ним доступ через единый интерфейс."),
            
            Question(question: ["Этот паттерн проектирования создает объекты путем полного копирования уже существующего объекта, а не путем создания через инициализатор",
                                "Какой порождающий шаблон проектирования создает объекты не через инициализатор, а путем полного копирования уже существующего объекта?"],
                     image: "",
                     optionA: "Prototype",
                     optionB: "Delegate",
                     optionC: "Proxy",
                     optionD: "Factory",
                     correctAnswer: 1,
                     questionId: 2604,
                     helpText: "Паттерн Prototype (прототип) — порождающий шаблон проектирования. Его суть в том, чтобы создавать объект не через инициализатор (как обычно это делается), а путем полного копирования уже существующего объекта. При этом должен быть предоставлен максимально удобный интерфейс для такого копирования."),
            
            Question(question: ["Cтруктурный шаблон проектирования, который представляет собой объект, контролирующий доступ к другому объекту, перехватывая все вызовы.",
                                "Какой паттерн представляет собой объект, контролирующий доступ к другому объекту, перехватывая все вызовы?",
                                "Этот стркутурный шаблон проектирования представляет собой объект, контролирующий доступ к другому объекту, перехватывая все вызовы"],
                     image: "",
                     optionA: "Proxy",
                     optionB: "Adapter",
                     optionC: "Bridge",
                     optionD: "Facade",
                     correctAnswer: 1,
                     questionId: 2605,
                     helpText: "Паттерн Proxy (прокси, «заместитель») — структурный шаблон проектирования. Представляет собой объект, который контролирует доступ к другому объекту, перехватывая все вызовы. При этом объект-прокси имеет тот же интерфейс, что и настоящий объект."),
            
            Question(question: ["Поведенческий шаблон проектирования, который предназначен для распределения обработки сообщения / события между разными объектами.",
                                "Какой паттерн предназначен для распределения обработки сообщения / события между разными объектами?",
                                "У какого поведенческого шаблона проектирования следующая структура: сначала один объект пытается обработать событие; если он не может этого сделать, то посылает его следующему обработчику?"],
                     image: "",
                     optionA: "Chain of Responsibility",
                     optionB: "Strategy",
                     optionC: "Visitor",
                     optionD: "Observer",
                     correctAnswer: 1,
                     questionId: 2606,
                     helpText: "Паттерн Chain of Responsibility (цепочка обязанностей) — поведенческий шаблон проектирования. Он предназначен для распределения обработки сообщения / события между разными объектами. Структура паттерна следующая: сначала один объект пытается обработать событие; если он не может этого сделать, то посылает его следующему обработчику. Все обработчики выстроены в последовательную цепочку и реализуют один протокол."),
            
            Question(question: ["Поведенческий шаблон проектирования, в котором центральную роль играют команды, становящиеся отдельными объектами (то, что должно быть выполнено, но через какое-то время)",
                                "В каком паттерне проектирования центральную роль играют команды, где объект команды — это то, что должно быть выполнено, но обычно через какое-то время?",
                                "Паттерн проектирования, в котором главный объект - команда, которая должна выполняться, но не сразу. Так же эти команды до выполнения хранятся в памяти и даже могут изменяться."],
                     image: "",
                     optionA: "Command",
                     optionB: "Composite",
                     optionC: "Chain Of Responsibility",
                     optionD: "Mediator",
                     correctAnswer: 1,
                     questionId: 2607,
                     helpText: "Паттерн Command (команда) — поведенческий шаблон проектирования. В этом паттерне центральную роль играют команды, которые становятся отдельными объектами. Объект команды — это то, что должно быть выполнено, но обычно через какое-то время. До этого момента объект команды хранится в памяти и даже может изменяться. Паттерн «команда» служит для того, чтобы описать и сохранить действие, которое должно быть выполнено позже."),
            
            Question(question: ["Паттерн, который применяется в системе, где есть много взаимодействующих друг с другом объектов, чтобы уменьшить связность между ними",
                                "Какой поведенческий шаблон проектирования применяется в системе, где есть много взаимодействующих друг с другом объектов, чтобы уменьшить связность между ними?",
                                "В каком паттерне проектирования объект взаимодействует с другим объектом не напрямую, а через посредника, который передает это взаимодействие всем другим объектам?"],
                     image: "",
                     optionA: "Mediator",
                     optionB: "Proxy",
                     optionC: "Memento",
                     optionD: "Delegate",
                     correctAnswer: 1,
                     questionId: 2608,
                     helpText: "Паттерн Mediator (посредник) — поведенческий шаблон проектирования. Он применяется в системе, где есть много взаимодействующих друг с другом объектов, чтобы уменьшить связность между ними. Объект взаимодействует не с другими напрямую, а с посредником, который уже передает это взаимодействие всем другим объектам. "),
            
            Question(question: ["Суть этого паттерна заключается в том, что в зависимости от состояния отображается разная информация, и нажатие обрабатывается по-своему"],
                     image: "",
                     optionA: "State",
                     optionB: "Prototype",
                     optionC: "Command",
                     optionD: "Mediator",
                     correctAnswer: 1,
                     questionId: 2609,
                     helpText: "В зависимости от состояния отображается разная информация, и нажатие обрабатывается по-своему. В этом суть паттерна State."),
            
            Question(question: ["В чем отличие паттерна State от паттерна Strategy?",
                                "Шаблон проектирования State отличается от шаблона Strategy этим",
                                "Чем отличается паттерн проектирования State от Strategy?"],
                     image: "",
                     optionA: "State затрагивает UI и логику",
                     optionB: "Только в названии",
                     optionC: "State не затрагивает логику",
                     optionD: "Strategy изменяет UI приложения",
                     correctAnswer: 1,
                     questionId: 2610,
                     helpText: "Отличие состоит в том, что состояние хранится приложением, и обязательно произойдет переход из одного состояния в другое. Также в стратегии, как правило, наша цель — не вдаваясь в реализацию, выполнить одно действие и получить результат. Состояние же влияет на множество компонентов — в нашем примере и на UI-приложения, и на логику работы."),
            
            Question(question: ["Допустим у нас есть ход первого игрока, ход второго игрока, и состояние завершения игры. Какой паттерн мы можем применить, чтобы управлять этими состояниями в нашем приложении?",
                                "Если в вашем приложении есть разные состояния, с помощью какого паттерна мы можем ими управлять через один общий интерфейс?"],
                     image: "",
                     optionA: "State",
                     optionB: "Proxy",
                     optionC: "Memento",
                     optionD: "Delegate",
                     correctAnswer: 1,
                     questionId: 2611,
                     helpText: "Правильный ответ: State"),
            
            Question(question: ["Какой паттерн для своей работы должен поддерживать NSCopying у класса, или иметь собственную реализацию протокола Copying?",
                                "Одна из ключевых особенностей данного шаблона проектирования в том, что класс должен поддерживать NSCopying или иметь собственную реализацию протокола Copying",
                                "Какой шаблон проектирования должен иметь собственную реализацию протокола Copying, или поддерживать NSCopying?"],
                     image: "",
                     optionA: "Prototype",
                     optionB: "Adapter",
                     optionC: "Delegate",
                     optionD: "Factory",
                     correctAnswer: 1,
                     questionId: 2612,
                     helpText: "Правильный ответ: Prototype. В Objective-C активно использовался протокол NSCopying. Им же можно воспользоваться и в Swift. Но наследие Objective-C дает о себе знать. Исправить все минусы поможет собственная реализация протокола Copying (да, нативного решения на чистом Swift, к сожалению, нет)."),
            
            Question(question: ["Структура какого паттерна состоит из трех объектов, Invoker -> Command -> Receiver?",
                                "Invoker -> Command -> Receiver является структурой этого паттерна",
                                "Какой паттерн проектирования имеет структуру, состоящую их трех объектов: Invoker, Command, Receiver?"],
                     image: "",
                     optionA: "Command",
                     optionB: "Receiver",
                     optionC: "Factory",
                     optionD: "Abstract Invoker",
                     correctAnswer: 1,
                     questionId: 2613,
                     helpText: "Рассмотрим структуру паттерна Command. Она состоит из трех объектов: Invoker -> Command -> Receiver. Invoker («вызывающий») — объект, который хранит команды и ставит их на исполнение. Это контроллер для команд. Command — непосредственно объект команды. Он инкапсулирует действие, которое должно быть выполнено позднее. Receiver («получатель») — объект, который получает команды. Именно он делает всю основную работу. Он получает команды, но они содержат лишь описание действия. Само действие делает receiver."),
            
            Question(question: ["Какой паттерн позволяет реализовать логирование (запись действий приложения в лог)?",
                                "Этот шаблон позволяет записывать действия приложения в лог, отдельный файл, который можно хранить на клиенте и при необходимости достать, чтобы отправить на сервер (например для крэш-аналитики)",
                                "Какой паттерн проектирования позволяет накапливать логи в отдельном классе, чтобы потом, когда накопится достаточное количество - сохранять их в файл?"],
                     image: "",
                     optionA: "Command",
                     optionB: "Receiver",
                     optionC: "Factory",
                     optionD: "Invoker",
                     correctAnswer: 1,
                     questionId: 2614,
                     helpText: "Логирование. Это запись действий приложения в лог — отдельный файл, который можно хранить на клиенте и при необходимости достать, чтобы отправить на сервер (а там уже разработчики будут смотреть логи и выяснять, что привело к ошибке в приложении). Запись большого количества текста в файл — не самая дешевая операция, и делать ее на каждый чих приложения затратно. Поэтому лучше складировать команды на запись логов в отдельном классе (роль invoker), а затем, когда логов накопится достаточно много (или приложение вот-вот выгрузится из памяти), все накопленные записи разом сохранить в файл."),
            
            Question(question: ["У какого паттерна мы можем наблюдать подобную древовидную структуру?",
                                "Какой паттерн обладает такой же древовидной структурой?"],
                     image: "AdvancedPatterns15",
                     optionA: "Composite",
                     optionB: "Component",
                     optionC: "Delegate",
                     optionD: "Factory",
                     correctAnswer: 1,
                     questionId: 2615,
                     helpText: "Подобная структура у паттерна Composite. Рассмотрим схему этого паттерна. Может быть сколько угодно классов, которые реализуют протокол, но их можно разделить на две части: композитные объекты и \"листья\". Композитные объекты (folder) содержат другие объекты, обычно в виде массива. Листья (файлы) не содержат других компонентов — так что являются конечными объектами в структуре."),
            
            Question(question: ["Схема какого паттерна здесь изображена?",
                                "На картинке изображена схема этого паттерна",
                                "Определите по схеме, какой паттерн указан на картинке"],
                     image: "AdvancedPatterns16",
                     optionA: "Chain of Responsibility",
                     optionB: "Command",
                     optionC: "Delegate",
                     optionD: "Adapter",
                     correctAnswer: 1,
                     questionId: 2616,
                     helpText: "На рисунке представлена схема паттерна Chain of responsibility. Определяется протокол Handler, которому должны соответствовать все обработчики события. Каждый из них имеет свойство next: Handler?, ссылающееся на следующий обработчик по цепочке (у последнего обработчика next будет nil). Каждый обработчик должен реализовать функцию handle(), которая и обрабатывает событие. В книге «банды четырех» описан классический пример применения этого паттерна: обработка нажатия пользователя на область экрана для вызова контекстной помощи. В зависимости от области нажатия нужно обработать его по-разному, и для этого создается цепочка обработчиков, каждый из которых может обработать нажатие в зависимости от входных условий."),
            
            Question(question: ["Паттерн, в котором помимо еще одного объекта есть объект colleague",
                                "Паттерн, в котором объект colleague должен взаимодействовать с другими такими же объектами через посредника",
                                "В этом шаблоне проектирования одному объекту colleague запрещено обращаться напрямую к другим таким же объектам, в обход посредника"],
                     image: "",
                     optionA: "Mediator",
                     optionB: "Chain of Responsibility",
                     optionC: "Colleague",
                     optionD: "Proxy",
                     correctAnswer: 1,
                     questionId: 2617,
                     helpText: "Классический вариант использования паттерна Mediator. По структуре: в паттерне два действующих лица — mediator и colleague. Оба представлены своим протоколом и соответствующими конкретными реализациями. Colleague — объект, который хочет взаимодействовать с другими такими же объектами. Он должен делать это через посредника mediator. Прямые обращения одного colleague к другому запрещены."),
            
            Question(question: ["Схема какого паттерна здесь изображена?",
                                "На картинке изображена схема этого паттерна",
                                "Определите по схеме, какой паттерн указан на картинке"],
                     image: "AdvancedPatterns18",
                     optionA: "Mediator",
                     optionB: "Chain of Responsibility",
                     optionC: "Colleague",
                     optionD: "Proxy",
                     correctAnswer: 1,
                     questionId: 2618,
                     helpText: "На схеме изображен паттерн Mediator."),
            
            Question(question: ["Какому паттерну подходит данная метафора?",
                                "Такая метафора подходит для этого паттерна проектирования"],
                     image: "AdvancedPatterns19",
                     optionA: "State",
                     optionB: "Prototype",
                     optionC: "Command",
                     optionD: "Decorator",
                     correctAnswer: 1,
                     questionId: 2619,
                     helpText: "Метафора про паттерн State - \"состояние\"."),
            
            Question(question: ["Какому паттерну проектирования подходит данная метафора?",
                                "Такая метафора подходит для этого паттерна проектирования"],
                     image: "AdvancedPatterns20",
                     optionA: "Prototype",
                     optionB: "State",
                     optionC: "Command",
                     optionD: "Decorator",
                     correctAnswer: 1,
                     questionId: 2620,
                     helpText: "Метафора про паттерн Prototype - \"прототип\"."),
            
            Question(question: ["Какому паттерну проектирования подходит данная метафора?",
                                "Такая метафора подходит для этого паттерна проектирования"],
                     image: "AdvancedPatterns21",
                     optionA: "Command",
                     optionB: "State",
                     optionC: "Prototype",
                     optionD: "Decorator",
                     correctAnswer: 1,
                     questionId: 2621,
                     helpText: "Метафора про паттерн Command - \"команда, действие\"."),
            
            Question(question: ["Какому паттерну проектирования подходит данная метафора?",
                                "Такая метафора подходит для этого паттерна проектирования"],
                     image: "AdvancedPatterns22",
                     optionA: "Decorator",
                     optionB: "State",
                     optionC: "Prototype",
                     optionD: "Command",
                     correctAnswer: 1,
                     questionId: 2622,
                     helpText: "Метафора про паттерн Decorator - \"декоратор\"."),
            
            Question(question: ["Какому паттерну проектирования подходит данная метафора?",
                                "Такая метафора подходит для этого паттерна проектирования"],
                     image: "AdvancedPatterns23",
                     optionA: "Proxy",
                     optionB: "State",
                     optionC: "Prototype",
                     optionD: "Command",
                     correctAnswer: 1,
                     questionId: 2623,
                     helpText: "Метафора про паттерн Proxy - \"прокси, заместитель\"."),
            
            Question(question: ["Какому паттерну проектирования подходит данная метафора?",
                                "Такая метафора подходит для этого паттерна проектирования"],
                     image: "AdvancedPatterns24",
                     optionA: "Composite",
                     optionB: "Proxy",
                     optionC: "Prototype",
                     optionD: "State",
                     correctAnswer: 1,
                     questionId: 2624,
                     helpText: "Метафора про паттерн Composite - \"компоновщик\"."),
            
            Question(question: ["Какому паттерну проектирования подходит данная метафора?",
                                "Такая метафора подходит для этого паттерна проектирования"],
                     image: "AdvancedPatterns25",
                     optionA: "Chain of Responsibility",
                     optionB: "Proxy",
                     optionC: "Composite",
                     optionD: "State",
                     correctAnswer: 1,
                     questionId: 2625,
                     helpText: "Метафора про паттерн Chain of Responsibility - \"цепочка обязанностей\"."),
            
            Question(question: ["Какому паттерну проектирования подходит данная метафора?",
                                "Такая метафора подходит для этого паттерна проектирования"],
                     image: "AdvancedPatterns26",
                     optionA: "Mediator",
                     optionB: "Proxy",
                     optionC: "Composite",
                     optionD: "State",
                     correctAnswer: 1,
                     questionId: 2626,
                     helpText: "Метафора про паттерн Mediator - \"посредник\"."),
            
            Question(question: ["Какой паттерн невозможно рассматривать в отрыве от концепции машины состояний?",
                                "Этот шаблон проектирования невозможно рассматривать в отрыве от концепции \"конечный автомат\""],
                     image: "",
                     optionA: "State",
                     optionB: "Prototype",
                     optionC: "Decorator",
                     optionD: "Visitor",
                     correctAnswer: 1,
                     questionId: 2627,
                     helpText: "Паттерн Состояние (State) невозможно рассматривать в отрыве от концепции машины состояний, также известной как стейт-машина или конечный автомат. Основная идея в том, что программа может находиться в одном из нескольких состояний, которые всё время сменяют друг друга. Набор этих состояний, а также переходов между ними, предопределён и конечен. Находясь в разных состояниях, программа может по-разному реагировать на одни и те же события, которые происходят с ней."),
            
            Question(question: ["Какому паттерну присущи следующие плюсы: избавляет от множества больших условных операторов машины состояний, концентрирует в одном месте код, связанный с определённым состоянием?",
                                "К какому паттерну относятся эти плюсы: концентрирует в одном месте код, связанный с определённым состоянием, упрощает код контекста?",
                                "Какой паттерн может неоправданно усложнить код, если состояний мало и они редко меняются?"],
                     image: "",
                     optionA: "State",
                     optionB: "Prototype",
                     optionC: "Delegate",
                     optionD: "Decorator",
                     correctAnswer: 1,
                     questionId: 2628,
                     helpText: "Преимущества и недостатки паттерна State (состояние): Избавляет от множества больших условных операторов машины состояний. Концентрирует в одном месте код, связанный с определённым состоянием. Упрощает код контекста. Может неоправданно усложнить код, если состояний мало и они редко меняются."),
            
            Question(question: ["Какому паттерну проектирования подходит данная аналогия?",
                                "Такая аналогия подходит для этого паттерна проектирования"],
                     image: "AdvancedPatterns29",
                     optionA: "State",
                     optionB: "Prototype",
                     optionC: "Decorator",
                     optionD: "Visitor",
                     correctAnswer: 1,
                     questionId: 2629,
                     helpText: "Аналогия про паттерн State - \"состояние\"."),
            
            Question(question: ["Какому паттерну присущи следующие преимущества: позволяет клонировать объекты, не привязываясь к их конкретным классам, меньше повторяющегося кода инициализации объектов?",
                                "К какому паттерну относятся следующие преимущества: ускоряет создание объектов, альтернатива созданию подклассов для конструирования сложных объектов? ",
                                "Какой паттерн имеет этот недостаток: сложно клонировать составные объекты, имеющие ссылки на другие объекты?"],
                     image: "",
                     optionA: "Prototype",
                     optionB: "Flyweight",
                     optionC: "Delegate",
                     optionD: "Adapter",
                     correctAnswer: 1,
                     questionId: 2630,
                     helpText: "Преимущества и недостатки паттерна Prototype (прототип): Позволяет клонировать объекты, не привязываясь к их конкретным классам. Меньше повторяющегося кода инициализации объектов. Ускоряет создание объектов. Альтернатива созданию подклассов для конструирования сложных объектов. Сложно клонировать составные объекты, имеющие ссылки на другие объекты."),
            
            Question(question: ["Какому паттерну присущи данные преимущества: убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно выполняют, позволяет реализовать простую отмену и повтор операций?",
                                "К какому паттерну относятся данные преимущества: позволяет реализовать отложенный запуск операций, позволяет собирать сложные команды из простых, реализует принцип открытости/закрытости?"],
                     image: "",
                     optionA: "Command",
                     optionB: "Composite",
                     optionC: "Chain of Responsibility",
                     optionD: "Mediator",
                     correctAnswer: 1,
                     questionId: 2631,
                     helpText: "Преимущества и недостатки паттерна Command (команда): Убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно выполняют. Позволяет реализовать простую отмену и повтор операций. Позволяет реализовать отложенный запуск операций. Позволяет собирать сложные команды из простых. Реализует принцип открытости/закрытости. Усложняет код программы из-за введения множества дополнительных классов."),
            
            Question(question: ["Какому паттерну присущи следующие преимущества: большая гибкость, чем у наследования, позволяет добавлять обязанности на лету, можно добавлять несколько новых обязанностей сразу?",
                                "К какому паттерну относится это преимущество: позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни, большая гибкость, чем у наследования?",
                                "У какого паттерна большая гибкость, чем у наследования, но есть недостатки в виде трудностей конфигурирования многократно обёрнутых объектов и обилия крошечных классов?"],
                     image: "",
                     optionA: "Decorator",
                     optionB: "Proxy",
                     optionC: "Composite",
                     optionD: "Mediator",
                     correctAnswer: 1,
                     questionId: 2632,
                     helpText: "Преимущества и недостатки паттерна Decorator (декоратор): Большая гибкость, чем у наследования. Позволяет добавлять обязанности на лету. Можно добавлять несколько новых обязанностей сразу. Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни. Трудно конфигурировать многократно обёрнутые объекты. Обилие крошечных классов."),
            
            Question(question: ["Какому паттерну присущи следующие преимущества: позволяет контролировать сервисный объект незаметно для клиента, может работать, даже если сервисный объект ещё не создан?",
                                "К какому паттерну относятся данные преимущества: может работать, даже если сервисный объект ещё не создан, может контролировать жизненный цикл служебного объекта?"],
                     image: "",
                     optionA: "Proxy",
                     optionB: "Decorator",
                     optionC: "Composite",
                     optionD: "Mediator",
                     correctAnswer: 1,
                     questionId: 2633,
                     helpText: "Преимущества и недостатки паттерна Proxy (прокси, заместитель): Позволяет контролировать сервисный объект незаметно для клиента. Может работать, даже если сервисный объект ещё не создан. Может контролировать жизненный цикл служебного объекта. Усложняет код программы из-за введения дополнительных классов. Увеличивает время отклика от сервиса."),
            
            Question(question: ["Какому паттерну присущи данные преимущества: упрощает архитектуру клиента при работе со сложным деревом компонентов, облегчает добавление новых видов компонентов?",
                                "К какому паттерну относится данный недостаток: создаёт слишком общий дизайн классов?"],
                     image: "",
                     optionA: "Composite",
                     optionB: "Delegate",
                     optionC: "Factory",
                     optionD: "Flyweight",
                     correctAnswer: 1,
                     questionId: 2634,
                     helpText: "Преимущества и недостатки паттерна Composite (компоновщик): Упрощает архитектуру клиента при работе со сложным деревом компонентов. Облегчает добавление новых видов компонентов. Создаёт слишком общий дизайн классов."),
            
            Question(question: ["Какому паттерну присущи данные преимущества: уменьшает зависимость между клиентом и обработчиками, реализует принцип единственной обязанности, реализует принцип открытости/закрытости?",
                                "К какому поведенческому паттерну относится данный недостаток: Запрос может остаться никем не обработанным?"],
                     image: "",
                     optionA: "Chain of Responsibility",
                     optionB: "Adapter",
                     optionC: "Bridge",
                     optionD: "Composite",
                     correctAnswer: 1,
                     questionId: 2635,
                     helpText: "Преимущества и недостатки паттерна Chain of Responsibility (цепочка обязанностей): Уменьшает зависимость между клиентом и обработчиками. Реализует принцип единственной обязанности. Реализует принцип открытости/закрытости. Запрос может остаться никем не обработанным."),
            
            Question(question: ["Какому паттерну присущи данные преимущества: устраняет зависимости между компонентами, позволяя повторно их использовать, упрощает взаимодействие между компонентами, централизует управление в одном месте?",
                                "К какому паттерну относится данный недостаток: Посредник может сильно раздуться?"],
                     image: "",
                     optionA: "Mediator",
                     optionB: "Abstract Factory",
                     optionC: "Builder",
                     optionD: "Prototype",
                     correctAnswer: 1,
                     questionId: 2636,
                     helpText: "Преимущества и недостатки паттерна Mediator (посредник): Устраняет зависимости между компонентами, позволяя повторно их использовать. Упрощает взаимодействие между компонентами. Централизует управление в одном месте. Посредник может сильно раздуться."),
            
            /// Добавить вопросы с сайта:
            /// https://refactoring.guru/ru/design-patterns/creational-patterns
            /// Сейчас пока только вопросы по понятиям и преимуществам с недостатками прописаны
            
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     correctAnswer: 1,
            //                     questionId: 2637,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     correctAnswer: 1,
            //                     questionId: 2638,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     correctAnswer: 1,
            //                     questionId: 2639,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     correctAnswer: 1,
            //                     questionId: 2640,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     correctAnswer: 1,
            //                     questionId: 2641,
            //                     helpText: ""),
        ]
    }
}
