
//  Created by Евгений Никитин on 15.04.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

class TheBasicsSet {
    static func getQuestions() -> [Question] {
        return [
            Question(question: ["С какой буквы должно начинаться имя переменной в Swift?",
                                "Мы должны писать имя переменной или константы с этой буквы",
                                "С какой буквы мы пишем имена переменных или констант в Swift?"],
                     image: "",
                     optionA: "С маленькой",
                     optionB: "С заглавной",
                     optionC: "По желанию",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 1,
                     helpText: "Хорошей практикой является использование названий в CamelCase. То есть названия начинаются с маленькой буквы. Если название состоит из нескольких слов, то только первое начинается с маленькой буквы."),
            
            Question(question: ["Какими должны быть имена переменных?",
                                "Какими должны быть имена констант или переменных?",
                                "Мы должны придумывать именно такими имена переменных или констант"],
                     image: "",
                     optionA: "Односложными",
                     optionB: "Универсальными",
                     optionC: "Уникальными",
                     optionD: "Одинаковыми",
                     correctAnswer: 3,
                     questionId: 2,
                     helpText: "Переменные и константы должны иметь уникальные имена. Нельзя использовать в программе несколько переменных и (или) констант с одними и теми же именами. Причем хорошей практикой является использование названий в так называемом верблюжем регистре или CamelCase. То есть названия начинаются с маленькой буквы. Если название состоит из нескольких слов, то только первое из них начинается с маленькой буквы."),
            
            Question(question: ["Возможно ли объявить нескольких констант в одну строку?",
                                "Можем ли мы объявить сразу две переменные в одну строку?",
                                "Возможно ли объявление двух и более переменных или констант в одну строку?"],
                     image: "",
                     optionA: "Нет, каждая с новой строки",
                     optionB: "Да, через обратный слеш",
                     optionC: "Да, через запятую",
                     optionD: "Да, через двоеточие",
                     correctAnswer: 3,
                     questionId: 3,
                     helpText: "Мы можем определить сразу несколько переменных и констант на одой строке. В этом случае они должны разделяться запятой."),
            
            Question(question: ["Можем ли мы менять значение переменной?",
                                "Изменяется ли значение, присвоенное переменной?",
                                "Возможно ли поменять значение, присвоенное переменной?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "Да, но только внутри цикла",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 4,
                     helpText: "Отличительной особенностью переменных является то, что мы можем изменять их значение многократно во время работы программы."),
            
            Question(question: ["Переменная, значение которой можно установить только один раз и нельзя изменить в дальнейшем",
                                "Значение этой переменной можно установить только один раз, без возможности в дальнейшем его менять" ],
                     image: "",
                     optionA: "Лямбда",
                     optionB: "Постоянная",
                     optionC: "Константа",
                     optionD: "",
                     correctAnswer: 3,
                     questionId: 5,
                     helpText: "Константы подобны переменным, они также хранят некоторое значение, за тем исключением, что определяются с помощью ключевого слова let, и мы не можем после их инициализации изменить их значение. Таким образом, если значение некоторой переменной в течении программы меняться не будет, то вместо этой переменной лучше использовать константу."),
            
            Question(question: ["Ключевое слово, которое используется для определения константы",
                                "Какое ключевое слово используется для определения константы?",
                                "Этим ключевым словом можно определить константу"],
                     image: "",
                     optionA: "static",
                     optionB: "set",
                     optionC: "var",
                     optionD: "let",
                     correctAnswer: 4,
                     questionId: 6,
                     helpText: "Константы подобны переменным, они также хранят некоторое значение, за тем исключением, что определяются с помощью ключевого слова let, и мы не можем после их инициализации изменить их значение. Таким образом, если значение некоторой переменной в течении программы меняться не будет, то вместо этой переменной лучше использовать константу."),
            
            Question(question: ["В каком единственном случае мы можем менять данные в константе?",
                                "Исключение, при котором мы можем перезаписывать значение константы?"],
                     image: "",
                     optionA: "Внутри функции",
                     optionB: "Только во ViewDidLoad()",
                     optionC: "Внутри цикла",
                     optionD: "",
                     correctAnswer: 3,
                     questionId: 7,
                     helpText: "Исключением является использование в цикле, где константа каждую итерацию будет перезаписываться."),
            
            Question(question: ["Какое ключевое слово используется для определения переменной?",
                                "Ключевое слово, которое используется для определения переменной",
                                "Этим ключевым словом можно определить переменную"],
                     image: "",
                     optionA: "var",
                     optionB: "let",
                     optionC: "func",
                     optionD: "set",
                     correctAnswer: 1,
                     questionId: 8,
                     helpText: "Для определения переменной используется ключевое слово var. Отличительной особенностью переменных является то, что мы можем изменять их значение многократно во время работы программы"),
            
            Question(question: ["Именнованный участок в памяти, в котором хранится некоторое значение",
                                "Как называется именнованный участок в памяти, в котором хранится некоторое значение?",
                                "Поименованная, либо адресуемая иным способом область памяти, адрес которой можно использовать для осуществления доступа к данным"],
                     image: "",
                     optionA: "Строка",
                     optionB: "Структура",
                     optionC: "Переменная или Константа",
                     optionD: "Библиотека",
                     correctAnswer: 3,
                     questionId: 9,
                     helpText: "Для хранения данных в Swift, как и в других языках программирования, используются переменные и константы. Переменная или константа представляет собой именнованный участок в памяти, в котором хранится некоторое значение."),
            
            Question(question: ["Тип данных, отвечающий за хранение отдельных Unicode-символов",
                                "Какой тип хранит отдельные символы?",
                                "Отдельные Unicode-символы хранятся именно в этом типе данных"],
                     image: "",
                     optionA: "Bool",
                     optionB: "Float",
                     optionC: "Character",
                     optionD: "String",
                     correctAnswer: 3,
                     questionId: 10,
                     helpText: "Для работы с текстом применяются два типа данных: Character и String. Character отвечает за хранение отдельных Unicode-символов, а String - за хранение произвольной текстовой информации."),
            
            Question(question: ["Тип данных, отвечающий за хранение произвольной текстовой информации",
                                "Какой тип данных хранит произвольный текст?",
                                "Произвольный строковый литерал можно хранить именно в этом типе"],
                     image: "",
                     optionA: "Float",
                     optionB: "String",
                     optionC: "Character",
                     optionD: "Bool",
                     correctAnswer: 2,
                     questionId: 11,
                     helpText: "Для работы с текстом применяются два типа данных: Character и String. Character отвечает за хранение отдельных Unicode-символов, а String - за хранение произвольной текстовой информации."),
            
            Question(question: ["Если мы точно уверены, что значение переменной меняться не будет, что нам нужно использовать?",
                                "Если мы уверены, что значение переменной не будет меняться, что нам нужно объявить вместо этого?"],
                     image: "",
                     optionA: "Переменную",
                     optionB: "Константу",
                     optionC: "Литерал",
                     optionD: "Структуру",
                     correctAnswer: 2,
                     questionId: 12,
                     helpText: "Кроме переменных для хранения данных в программе могут использоваться константы. Константы подобны переменным, они также хранят некоторое значение, за тем исключением, что определяются с помощью ключевого слова let, и мы не можем после их инициализации изменить их значение. Таким образом, если значение некоторой переменной в течении программы меняться не будет, то вместо этой переменной лучше использовать константу."),
            
            Question(question: ["Какой тип данных хранит числа, не содержащие дробной части (например 42 или -23)?",
                                "В каком типе храняться целые числа со знаком?",
                                "Любые целые числа без дробной части хранятся именно в этом типе"],
                     image: "",
                     optionA: "UInt",
                     optionB: "Int",
                     optionC: "Float",
                     optionD: "Double",
                     correctAnswer: 2,
                     questionId: 13,
                     helpText: "Int: целое число со знаком, например, 1, -30, 458. На 32-разрядных платформах эквивалентен Int32, а на 64-разрядных - Int64."),
            
            Question(question: ["Все типы в Swift пишутся с ...",
                                "С какой буквы надо писать все типы в Свифт?",
                                "Именно с этой буквы пишутся все типы в Swift"],
                     image: "",
                     optionA: "Строчной буквы",
                     optionB: "На наше усмотрение",
                     optionC: "Заглавной буквы",
                     optionD: "",
                     correctAnswer: 3,
                     questionId: 14,
                     helpText: "Все типы в Swift пишутся с заглавной буквы, просто запомните это."),
            
            Question(question: ["Как получить доступ к минимальному и максимальному значению каждого типа целого числа?",
                                "Как получить минимальное и максимальное число у Int или UInt?",
                                "Именно через эти свойства мы можем получить доступ к максимальному и минимальному числу Int и UInt"],
                     image: "",
                     optionA: "first и last",
                     optionB: "min и max",
                     optionC: "count",
                     optionD: "first и max",
                     correctAnswer: 2,
                     questionId: 15,
                     helpText: "Вы можете получить минимальное и максимальное значение каждого числа с помощью свойств min и max."),
            
            Question(question: ["Какой тип может хранить более длинные дробные числа?",
                                "В каком типе с плавающей точкой может храниться более длинная дробная часть?",
                                "Именно в этом типе может храниться наибольшее число десятичных знаков"],
                     image: "",
                     optionA: "Double",
                     optionB: "Float",
                     optionC: "UInt",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 16,
                     helpText: "Double является 64битным числом с плавающей точкой – его следует использовать, когда значения должны быть очень большими или особенно точными. Он имеет точность в 15 десятичных знаков, тогда как Float – только 6."),
            
            Question(question: ["Какой тип хранит только положительные целые числа?",
                                "Тип, хранящий только целые числа без знака",
                                "В этом типе могут храниться только положительные целые числа"],
                     image: "",
                     optionA: "Int",
                     optionB: "Float",
                     optionC: "UInt",
                     optionD: "Double",
                     correctAnswer: 3,
                     questionId: 17,
                     helpText: "Swift предусматривает беззнаковый тип целого числа - UInt (Unsigned integer), который имеет тот же размер что и разрядность системы. Используйте UInt, только когда вам действительно нужен тип беззнакового целого числа. Если это не так, использовать Int предпочтительнее, даже когда известно, что значения будут неотрицательными. Постоянное использование Int для целых чисел способствует совместимости кода, позволяет избежать преобразования между разными типами чисел, и соответствует выводу типа целого числа."),
            
            Question(question: ["Фиксированная последовательность символов, окруженная двойными кавычками",
                                "Последовательность произвольных символов внутри двойных кавычек",
                                "Этот литерал состоит из какой-либо последовательности символов"],
                     image: "",
                     optionA: "Числовой литерал",
                     optionB: "Строковый литерал",
                     optionC: "Литерал пустого множества",
                     optionD: "Пустой литерал массива",
                     correctAnswer: 2,
                     questionId: 18,
                     helpText: "Фиксированная последовательность символов, окруженная двойными кавычками, называется строковым литералом. Обычно используется как начальное значение для инициализации константы или переменной, при этом тип можно объявить неявно."),
            
            Question(question: ["Фиксированная последовательность цифр",
                                "Последовательность цифр, начинающаяся с префиксного оператора «-» или «+»",
                                "Как называется любой из этих примеров: «-2234», «10», «0»?"],
                     image: "",
                     optionA: "Оператор",
                     optionB: "Числовой литерал",
                     optionC: "Строковый литерал",
                     optionD: "Случайное число",
                     correctAnswer: 2,
                     questionId: 19,
                     helpText: "Фиксированная последовательность цифр, начинающаяся либо с цифры, либо с префиксного оператора «минус» или «плюс», называется числовым литералом."),
            
            Question(question: ["Как можно объявлять тип данных?",
                                "В Swift можно объявить тип данных несколькими способами, как?",
                                "Именно так в Swift можно объявлять тип данных у константы или переменной"],
                     image: "",
                     optionA: "Внятно",
                     optionB: "Неявно",
                     optionC: "Явно или Неявно",
                     optionD: "Внятно или Явно",
                     correctAnswer: 3,
                     questionId: 20,
                     helpText: "Явно, указывая тип данных при объявлении переменной, через двоеточие. Либо неявно, инициализируя значение в переменной или константе (из которого XCode поймет, какой тип данных присвоить этому значению)."),
            
            Question(question: ["Можно ли использовать переменную с явным, не опциональным типом данных, до ее инициализации?",
                                "Есть переменная с явным, не опциональным типом данных, можете ли вы использовать ее до инициализации?",
                                "Можно ли использовать переменную до инициализации, если она не является опционалом?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     correctAnswer: 2,
                     questionId: 21,
                     helpText: "Использование переменной или константы до ее инициализации в Swift невозможно (кроме значений с опциональными типами)."),
            
            Question(question: ["Какой тип может хранить любое целое число в пределах от -2 147 483 648 до 2 147 483 647?",
                                "Тип, умеющий хранить любое целое число от -2 147 483 648 до 2 147 483 647?",
                                "Именно этот тип может хранить любое целое число от -2 147 483 648 до 2 147 483 647"],
                     image: "",
                     optionA: "Uint32",
                     optionB: "Decimal",
                     optionC: "Int32",
                     optionD: "Int64",
                     correctAnswer: 3,
                     questionId: 22,
                     helpText: "Значения от -2 147 483 648 до 2 147 483 647 соответствуют Int32."),
            
            Question(question: ["Если в коде не указать размер целого числа, каким оно будет?",
                                "Каким будет размер числа, если не указать конкретное значение при явном объявлении типа?",
                                "Каким установится размер целого числа, если в коде не указать его явно?"],
                     image: "",
                     optionA: "Согласно разрядности системы",
                     optionB: "32",
                     optionC: "64",
                     optionD: "128",
                     correctAnswer: 1,
                     questionId: 23,
                     helpText: "Если не указано иного, то размер числа всегда соответствует разрядности системы."),
            
            Question(question: ["Как называется объявление переменной с присваиванием ей значения?",
                                "Объявление переменной с присваиванием ей значения",
                                "Присвоение объявленному объекту начального значения"],
                     image: "",
                     optionA: "Инаугурация",
                     optionB: "Возведение",
                     optionC: "Объявление",
                     optionD: "Инициализация",
                     correctAnswer: 4,
                     questionId: 24,
                     helpText: "Инициализация - подготовительный процесс экземпляра класса, структуры или перечисления для дальнейшего использования. Этот процесс включает в себя установку начальных значений для каждого свойства хранения этого экземпляра и проведение любых настроек или инициализации, которые нужны до того, как экземпляр будет использоваться."),
            
            Question(question: ["Какую точность в десятичных знаках имеет тип Double?",
                                "Сколько десятичных цифр может хранить тип Double?",
                                "Double может хранить именно столько цифр после запятой"],
                     image: "",
                     optionA: "15 десятичных цифр",
                     optionB: "6 десятичных цифр",
                     optionC: "12 десятичных цифр",
                     optionD: "18 десятичных цифр",
                     correctAnswer: 1,
                     questionId: 25,
                     helpText: "Double является 64битным числом с плавающей точкой. Он имеет точность в 15 десятичных знаков."),
            
            Question(question: ["Какую точность в десятичных знаках имеет тип Float?",
                                "Сколько десятичных цифр может хранить тип Float?",
                                "Float может хранить именно столько цифр после запятой"],
                     image: "",
                     optionA: "4 десятичных цифр",
                     optionB: "6 десятичных цифр",
                     optionC: "12 десятичных цифр",
                     optionD: "10 десятичных цифр",
                     correctAnswer: 2,
                     questionId: 26,
                     helpText: "Float имеет точность в 6 десятичных знаков."),
            
            Question(question: ["Если равноценно использование обоих типов с плавающей точкой, использование какого предпочтительнее?",
                                "В случаях, где возможно использование обоих типов (Float и Double), какой предпочтительнее?",
                                "В ситуациях, где нужна бОльшая точность вычислений, какой тип необходимо использовать?"],
                     image: "",
                     optionA: "Double",
                     optionB: "Float",
                     optionC: "Character",
                     optionD: "String",
                     correctAnswer: 1,
                     questionId: 27,
                     helpText: "Double имеет точность минимум 15 десятичных цифр, в то время как точность Float может быть всего лишь 6 десятичных цифр. Соответствующий тип числа с плавающей точкой используется в зависимости от характера и диапазона значений, c которыми вы должны работать в коде. В случаях, где возможно использование обоих типов, предпочтительным считается Double."),
            
            Question(question: ["Можете ли вы передать тип Int, если некоторая часть кода ожидает тип String?",
                                "Если некоторая часть кода ожидает тип String, можете ли вы передать Character?",
                                "Можете ли вы передать положительное число типа Int32, если некоторая часть кода ожидает Uint32?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "В некоторых случаях",
                     optionD: "",
                     correctAnswer: 2,
                     questionId: 28,
                     helpText: "Swift - язык со строгой типизацией. Язык со строгой типизацией призывает вас иметь четкое представление о типах значений, с которыми может работать ваш код. Если часть вашего кода ожидает String (например), вы не сможете передать ему Int (или любой другой тип, кроме String) по ошибке."),
            
            Question(question: ["Cколько двойных кавычек нужно ставить при открытии и закрытии многострочного строкового литерала?",
                                "Какое количество двойных кавычек ставится при открытии многострочного строкового литерала?",
                                "При закрытии открытии многострочного строкового литерала ставится именно столько двойных кавычек"],
                     image: "",
                     optionA: "По одной",
                     optionB: "По две",
                     optionC: "По три",
                     optionD: "По четыре",
                     correctAnswer: 3,
                     questionId: 29,
                     helpText: "Если вам нужно создать строку, которая поддерживает многострочный вид, используйте литерал многострочной строки - последовательность символов, обернутых в три двойные кавычки. Многострочный литерал строки включает в себя все строки между тремя открывающими и тремя закрывающими кавычками. Строка начинается на первой строке после открывающих кавычек, а заканчивается на строке предшествующей закрывающим кавычкам."),
            
            Question(question: ["Каким символом осуществляется перенос строки в многострочном строковом литерале (в коде), позволяющий не отображать символ переноса строки в качестве части значения этой строки?",
                                "Этот символ может перенести строку многострочного литерала только внутри кода (для лучшего чтения), не отображая перенос строки как часть значения этой строки"],
                     image: "",
                     optionA: "Звездочка",
                     optionB: "Обратный слеш",
                     optionC: "Тире",
                     optionD: "",
                     correctAnswer: 2,
                     questionId: 30,
                     helpText: "Если вы хотите использовать символ переноса строки для того, чтобы сделать ваш код более читаемым, но вы не хотите чтобы символ переноса строки отображался в качестве части значения строки, то вам нужно использовать символ обратного слеша в конце этих строк. Проще говоря, если вы хотите перенести строку внутри кода, чтобы сделать его более читаемым, но не хотите, чтобы после компиляции эта строка также перенеслась."),
            
            Question(question: ["Как можно инициализировать пустую строку?",
                                "Как инициализируется пустой тип String?",
                                "Инициализация пустой строки происходит именно таким(ими) способом(ами)"],
                     image: "",
                     optionA: "= (String))",
                     optionB: "= [String]",
                     optionC: "= String()",
                     optionD: "",
                     correctAnswer: 3,
                     questionId: 31,
                     helpText: "Чтобы создать пустое String значение в качестве отправной точки для создания более длинных строк, либо присвойте литерал пустой строки к переменной, либо инициализируйте объект String c помощью синтаксиса инициализации: = String()."),
            
            Question(question: ["Способ создать новое значение типа String из разных констант, переменных, литералов и выражений, включая их значения в строковый литерал",
                                "Создание нового String-значения из разных констант, переменных, литералов и выражений, включая их значения в строковый литерал",
                                "Включение разных значений в String, используя обратный слеш и круглые скобки, называется?"],
                     image: "",
                     optionA: "Конкатенация",
                     optionB: "Интерполяция",
                     optionC: "Объединение строк",
                     optionD: "Вкрапление значений",
                     correctAnswer: 2,
                     questionId: 32,
                     helpText: "Интерполяция строк - способ создать новое значение типа String из разных констант, переменных, литералов и выражений, включая их значения в строковый литерал. Каждый элемент, который вы вставляете в строковый литерал, должен быть помещен в скобки и находиться внутри двойных кавычек литерала, а перед открывающей скобкой должен стоять знак обратного слэша."),
            
            Question(question: ["Каким образом можно добавить значение типа Character к переменной типа String?",
                                "Как мы можем добавить один Character к переменной типа String?",
                                "Используя какой метод мы можем добавить Character к переменной String?"],
                     image: "",
                     optionA: "Через оператор сложения",
                     optionB: "Конкатенация",
                     optionC: "Приведение типов",
                     optionD: "Используя String append",
                     correctAnswer: 4,
                     questionId: 33,
                     helpText: "Вы можете добавить значение типа Character к переменной типа String, используя метод String append. Вы не можете добавить String или Character к уже существующей переменной типа Character, потому что значение типа Character должно состоять только из одиночного символа."),
            
            Question(question: ["Можно ли сравнивать две строки?",
                                "Возможно ли сравнение двух значений типа String?",
                                "Можем ли мы сравнить два значения String?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Только ==",
                     optionC: "Только !=",
                     optionD: "Да",
                     correctAnswer: 4,
                     questionId: 34,
                     helpText: "Swift предусматривает три способа сравнения текстовых значений: равенство строк и символов, равенство префиксов, и равенство суффиксов. Равенство строк и символов проверяется оператором равенства (==) и оператором неравенства (!=). Два String значения (или два Character значения) считаются равными, если их расширенные наборы графем канонически эквивалентны. Расширенные наборы графем канонически эквивалентны, если они имеют один и тот же языковой смысл и внешний вид, даже если они изначально состоят из разных скалярных величин Юникода."),
            
            Question(question: ["Что вернется, при сравнении двух String?",
                                "Какой тип вернется в результате сравнения двух String значений?",
                                "Что мы получим после сравнения двух Character?"],
                     image: "",
                     optionA: "Bool",
                     optionB: "String",
                     optionC: "Character",
                     optionD: "1 или 0",
                     correctAnswer: 1,
                     questionId: 35,
                     helpText: "При сравнении String или Character возвращается Bool-значение (true или false)."),
            
            Question(question: ["Какой тип будет присвоен переменной с изображения?",
                                "Какой тип будет присвоен при подобной неявной типизации?"],
                     image: "TheBasics36",
                     optionA: "Float",
                     optionB: "Double",
                     optionC: "Trouble",
                     optionD: "Decimal",
                     correctAnswer: 2,
                     questionId: 36,
                     helpText: "При неявной типизации, числу с плавающей точкой присваивается тип Double, так как он является предпочтительным выбором."),
            
            Question(question: ["Что мы получим, при попытке запустить этот код?"],
                     image: "TheBasics37",
                     optionA: "Переменной присвоится число",
                     optionB: "Ничего не произойдет",
                     optionC: "Столкнемся с ошибой",
                     optionD: "Переменная обнулится",
                     correctAnswer: 3,
                     questionId: 37,
                     helpText: "Swift является типобезопасным языком со строгой типизацией, поэтому после того, как мы присвоили переменной тип, мы не можем его изменить. Так, в этом случае мы столкнемся с ошибкой. Ошибка возникает, так как переменная name ожидает строковый литерал, а число с плавающей точкой не является строкой и не соответствует переменной name по типу."),
            
            Question(question: ["Набор символов, зарезервированный языком программирования?",
                                "Зарезервированные языком программирования наборы символов, которые не могут быть использованы в качестве идентификаторов"],
                     image: "",
                     optionA: "Ключевое слово",
                     optionB: "Функция",
                     optionC: "Замыкание",
                     optionD: "Функция",
                     correctAnswer: 1,
                     questionId: 38,
                     helpText: "Ключевые слова зарезервированы и не могут быть использованы в качестве идентификаторов, если не помещены в одиночные кавычки. Ключевые слова, кроме inout, var, и let могут быть использованы в качестве внешних имен параметров в объявлении функции или в вызове функции без необходимости помещать их в одиночные кавычки."),
            
            Question(question: ["Что мы получим, при сравнении переменных name и char?"],
                     image: "TheBasics39",
                     optionA: "Ошибку",
                     optionB: "false",
                     optionC: "true",
                     optionD: "Ничего",
                     correctAnswer: 3,
                     questionId: 39,
                     helpText: "Хотя мы и присваиваем переменной char всего один отдельный символ, без явного указания типа данных Swift автоматически присвоит тип String, поэтому две этих переменных могут сравниваться, и результатом сравнения будет true (потому что в данном случае значения у переменных равны)"),
            
            Question(question: ["Что мы получим, при сравнении переменных name и name2?"],
                     image: "TheBasics40",
                     optionA: "false",
                     optionB: "Ошибку сравнения",
                     optionC: "Ничего",
                     optionD: "true",
                     correctAnswer: 2,
                     questionId: 40,
                     helpText: "Перед нами две переменных с разными значениями, и если поторопиться, то можно ответить, что результатом сравнения будет false, так как их значения не равны. Но в данном случае, у переменных разные типы данных, и подобное сравнение вызовет ошибку Binary operator '==' cannot be applied to operands of type 'String' and 'Character'"),
            
            Question(question: ["Являются ли все базовые типы (Int, String, Double, Bool) в Swift хешируемыми?",
                                "Все базовые типы (Int, String, Double, Bool) в Swift являются хешируемыми, так ли это?",],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "Все, кроме Bool",
                     optionD: "Все, кроме String",
                     correctAnswer: 1,
                     questionId: 41,
                     helpText: "Все базовые типы Swift (Int, String, Double, Bool) являются хешируемыми типами по умолчанию и могут быть использованы в качестве типов значений множества или в качестве типов ключей словаря. Значения членов перечисления без каких-либо связанных значений так же являются хешируемыми по умолчанию."),
            
            Question(question: ["Что позволяет создавать и передавать группы значений, и возвращать несколько значений из функции?",
                                "С помощью этого можно вернуть несколько значений из функции как одно целое значение",
                                "С помощью чего мы можем создавать и передавать группы значений в Swift?"],
                     image: "",
                     optionA: "Кортеж",
                     optionB: "Опционал",
                     optionC: "Множество",
                     optionD: "Переменная",
                     correctAnswer: 1,
                     questionId: 42,
                     helpText: "В дополнение к знакомым типам, Swift включает расширенные типы, которых нет в Objective-C. К ним относятся кортежи, которые позволяют создавать и передавать группы значений. Кортежи могут возвращать несколько значений из функции как одно целое значение."),
            
            Question(question: ["Тип, позволяющий работать с отсутствующими значениями",
                                "Какой тип позволяет работать с отсутствующими значениями?",
                                "С отсутствующими значениями можно работать с помощью этого типа"],
                     image: "",
                     optionA: "Тип кортежа",
                     optionB: "Опциональный тип",
                     optionC: "Тип коллекции",
                     optionD: "",
                     correctAnswer: 2,
                     questionId: 43,
                     helpText: "Swift также включает опциональные типы, которые позволяют работать с отсутствующими значениями. Опциональные значения говорят либо «здесь есть значение, и оно равно х», либо «здесь нет значения вообще». Опциональные типы подобны использованию nil с указателями в Objective-C, но они работают со всеми типами, не только с классами. Опциональные значения безопаснее и выразительнее чем nil указатели в Objective-C, и находятся в сердце многих наиболее мощных особенностей Swift."),
            
            Question(question: ["Можем ли мы передать опциональный String куску кода, который ожидает неопциональный String?",
                                "Можете ли вы передать опциональный тип Double куску кода, который ждет неопциональный тип Double?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     correctAnswer: 2,
                     questionId: 44,
                     helpText: "Swift - язык типобезопасный, что означает, что Swift помогает вам понять, с какими типами значений ваш код может работать. Если кусок вашего кода ожидает String, безопасность типов не даст вам передать ему Int по ошибке. Кроме того, безопасность типов не позволит вам случайно передать опциональный String куску кода, который ожидает неопциональный String. Безопасность типов позволяет вам улавливать и исправлять ошибки как можно раньше в процессе разработки."),
            
            Question(question: ["Выберите соответствующий вариант: Объявляем константу с именем numbers, тип которой будет Double со значением 1.0.",
                                "Как мы запишем следующее: Объявляем константу с именем numbers, тип которой будет Double со значением 1.0."],
                     image: "",
                     optionA: "let numbers: Double = 1.0",
                     optionB: "var numbers: Double = 1.0",
                     optionC: "let numbers = Double(1.0)",
                     optionD: "let numbers = Double : 1.0",
                     correctAnswer: 1,
                     questionId: 45,
                     helpText: "Правильный ответ будет: let numbers: Double = 1.0."),
            
            Question(question: ["Что не могут содержать имена констант и переменных?",
                                "Это нельзя использовать при написании имен констант и переменных",
                                "Выберите что не могут содержать имена переменных и констант?"],
                     image: "",
                     optionA: "Unicode-символы",
                     optionB: "Латинские буквы",
                     optionC: "Нижнее подчеркивание",
                     optionD: "Пробелы и стрелки",
                     correctAnswer: 4,
                     questionId: 46,
                     helpText: "Имена констант и переменных не могут содержать пробелы, математические символы, стрелки, приватные (или невалидные) кодовые точки Unicode, а так же символы отрисовки линий или прямоугольников. Так же имена не могут начинаться с цифр, хотя цифры могут быть включены в имя в любом другом месте. "),
            
            Question(question: ["Можем ли мы после объявления константы, дальше по коду изменить ее на переменную?",
                                "После объявление переменной, дальше по коду, можем ли мы поменять ее на константу?",
                                "Можем ли мы менять константы на переменные, а переменные на константы?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     correctAnswer: 2,
                     questionId: 47,
                     helpText: "Если вы объявили константу или переменную определенного типа, то вы не можете объявить ее заново с тем же именем или заставить хранить внутри себя значение другого типа. Также вы не можете изменить константу на переменную, а переменную на константу."),
            
            Question(question: ["Какая глобальная функция может вывести одно или более значений в консоль?",
                                "Глобальная функция, которая используется для выведения значений в консоль",
                                "Функция, являющаяся глобальной, и позволяющая выводить одно или более значений в консоль?"],
                     image: "",
                     optionA: "print(_:separator:terminator:)",
                     optionB: "show()",
                     optionC: "alert()",
                     optionD: "Console.WriteLine",
                     correctAnswer: 1,
                     questionId: 48,
                     helpText: "Функция print(_:separator:terminator:) является глобальной, которая выводит одно или более значений в подходящем виде. В Xcode, например, функция print(_:separator:terminator:) выводит значения в консоль. Параметры separator и terminator имеют дефолтные значения, так что при использовании функции их можно просто пропустить. По умолчанию функция заканчивает вывод символом переноса строки. Чтобы вывести в консоль значения без переноса на новую строку, вам нужно указать пустую строку в параметре terminator."),
            
            Question(question: ["Как называется игнорируемый компилятором, неисполняемый текст в коде?",
                                "Как называется неисполняемый текст в коде?",
                                "Что нужно добавить, чтобы у вас появился неисполняемый участок кода?"],
                     image: "",
                     optionA: "Комментарий",
                     optionB: "Исключение",
                     optionC: "Примечание",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 49,
                     helpText: "Используйте комментарии, чтобы добавить неисполняемый текст в коде, как примечание или напоминание самому себе. Комментарии игнорируются компилятором Swift во время компиляции кода. Комментарии в Swift очень похожи на комментарии в C. Однострочные комментарии начинаются с двух слешей (//), многострочные комментарии начинаются со слеша и звездочки (/*) и заканчиваются звездочкой, за которой следует слеш (*/). Внутри многострочного комментария вы можете поместить любой участок кода, который хотите сделать неисполняемым."),
            
            Question(question: ["Один случай, когда в Swift необходимо ставить точку с запятой (;) в коде?",
                                "В каком случае вам необходимо будет поставить точку с запятой (;) в коде?",
                                "В этом случае вам нужно ставить точку с запятой в коде"],
                     image: "",
                     optionA: "После каждого выражения",
                     optionB: "Объявление двух переменных",
                     optionC: "Несколько выражений на строке",
                     optionD: "",
                     correctAnswer: 3,
                     questionId: 50,
                     helpText: "В отличие от многих других языков, Swift не требует писать точку с запятой (;) после каждого выражения в коде, хотя вы можете делать это, если хотите. Однако точки с запятой требуются, если вы хотите написать несколько отдельных выражений на одной строке. Пример: let name = SomeValue; print(name)."),
            
            Question(question: ["Как тип будет у константы number?",
                                "Выберите правильный тип, который Swift происвоит константе number?",
                                "У константы number будет именно такой тип"],
                     image: "TheBasics51",
                     optionA: "Int",
                     optionB: "Float",
                     optionC: "Double",
                     optionD: "Character",
                     correctAnswer: 3,
                     questionId: 51,
                     helpText: "Если объединить целые литералы и литералы с плавающей точкой в одном выражении, в этом случае тип будет выводиться как Double. Swift всегда выбирает Double (вместо Float), когда выводит тип чисел с плавающей точкой. Литеральное значение 1 не имеет явного типа само по себе, так что соответствующий тип Double выводится из наличия литерала с плавающей точкой как части сложения."),
            
            Question(question: ["Как изменить имя существующего типа на более подходящее по контексту?",
                                "Как вы можете изменить имя существующего типа на подходящее по контексту?",
                                "Как можно задать альтернативное имя для существующего типа?"],
                     image: "",
                     optionA: "Создать typealias",
                     optionB: "Создать копию типа",
                     optionC: "Создать контекстное имя",
                     optionD: "Это невозможно",
                     correctAnswer: 1,
                     questionId: 52,
                     helpText: "Псевдонимы типов задают альтернативное имя для существующего типа. Можно задать псевдоним типа с помощью ключевого слова typealias. Псевдонимы типов полезны, когда вы хотите обратиться к существующему типу по имени, которое больше подходит по контексту. После того как вы один раз задали псевдоним типа, вы можете использовать псевдоним везде, где вы хотели бы его использовать. "),
            
            Question(question: ["Какие две логические константы предусматривает Swift для типа Bool?",
                                "В Swift есть две логические постоянные для типа Bool, какие?",
                                "Какие два логических значения мы можем присваивать переменным типа Bool?"],
                     image: "",
                     optionA: "true и false",
                     optionB: "true и not true",
                     optionC: "1 и 0",
                     optionD: "truth и false",
                     correctAnswer: 1,
                     questionId: 53,
                     helpText: "В Swift есть простой логический тип Bool. Этот тип называют логическим, потому что он может быть только true или false. Swift предусматривает две логические константы, true и false соответственно. Так же как с Int и Double в предыдущих главах, вам не нужно указывать константы или переменные как Bool, если при создании вы присвоили им значения true или false. Вывод типов помогает сделать код Swift кратким и читабельным тогда, когда вы создаете константы или переменные со значениями которые точно известны."),
            
            Question(question: ["Как корректно обратиться в первому элементу кортежа?",
                                "Каким образом мы можем обратиться к первому элементу кортежа?",
                                "Мы можем обратиться к первому элементу кортежа через числовой индекс, как именно?"],
                     image: "",
                     optionA: "someTuples.0",
                     optionB: "someTuples.1",
                     optionC: "someTuples[0]",
                     optionD: "someTuples(1)",
                     correctAnswer: 1,
                     questionId: 54,
                     helpText: "Вы можете разложить содержимое кортежа на отдельные константы и переменные, к которым можно получить доступ привычным способом. Если вам нужны только некоторые из значений кортежа, вы можете игнорировать части кортежа во время разложения с помощью символа подчеркивания (_). В качестве альтернативы можно получать доступ к отдельным частям кортежа, используя числовые индексы, начинающиеся с нуля."),
            
            Question(question: ["Когда мы можем дать имена отдельным элементам кортежа?",
                                "В какой момент мы можем дать имена отдельным элементам кортежа?"],
                     image: "",
                     optionA: "Во время объявления",
                     optionB: "После инициализации",
                     optionC: "После первого использования",
                     optionD: "В момент обращения к элементу",
                     correctAnswer: 1,
                     questionId: 55,
                     helpText: "Вы можете давать имена отдельным элементам кортежа во время объявления. Например: let gameRecord = (questionNumber: 50, score: 49)."),
            
            Question(question: ["Какой тип используется, когда значение может отсутствовать?",
                                "Если значение можно отсутствовать, какой тип мы будем использовать?",
                                "Этот тип используется, если значение может отсутствовать"],
                     image: "",
                     optionA: "Опциональный",
                     optionB: "Логический Bool",
                     optionC: "Кортеж",
                     optionD: "Неявный тип",
                     correctAnswer: 1,
                     questionId: 56,
                     helpText: "Опциональные типы используются в тех случаях, когда значение может отсутствовать. Опциональный тип подразумевает, что возможны два варианта: или значение есть, и его можно извлечь из опционала, либо его вообще нет."),
            
            Question(question: ["Какой тип Swift присвоит константе convertedNum?",
                                "Константе convertedNum присвоится именно этот тип",
                                "Swift присвоит этот тип константе convertedNum"],
                     image: "TheBasics57",
                     optionA: "Int?",
                     optionB: "Int",
                     optionC: "String",
                     optionD: "Столкнемся с ошибкой",
                     correctAnswer: 1,
                     questionId: 57,
                     helpText: "Поскольку метод Int() может иметь недопустимый аргумент, он возвращает опциональный Int, вместо Int. Опциональный Int записывается как Int?, а не Int. Знак вопроса означает, что содержащееся в ней значение является опциональным, что означает, что он может содержать некое Int значение, или он может вообще не содержать никакого значения. (Он не может содержать ничего другого, например, Bool значение или значение String. Он либо Int, либо вообще ничто)."),
            
            Question(question: ["Каким образом мы можем установить опциональную переменную в состояние отсутствия значения?",
                                "Каким путем вы можете присвоить опциональной переменной отсутствующее значение?",
                                "Отсутствующее значение для опциональной переменной можно установить именно так"],
                     image: "",
                     optionA: "Присвоить nil",
                     optionB: "Присвоить 0",
                     optionC: "Присвоить литерал пустого массива",
                     optionD: ".removeValue",
                     correctAnswer: 1,
                     questionId: 58,
                     helpText: "Мы можем установить опциональную переменную в состояние отсутствия значения, путем присвоения ему специального значения nil. nil не может быть использован с не опциональными константами и переменными. Если значение константы или переменной при определенных условиях в коде должно когда-нибудь отсутствовать, всегда объявляйте их как опциональное значение соответствующего типа."),
            
            Question(question: ["Каким образом мы можем проверить, содержит ли опционал значение?",
                                "Как мы можем узнать, содержит опционал значение или нет?",
                                "Таким образом вы можете узнать, содержит опционал значение или нет"],
                     image: "",
                     optionA: "Сравнивая с nil через if",
                     optionB: "Через оператор ===",
                     optionC: "Внутри цикла for-in",
                     optionD: "Через forced unwrap",
                     correctAnswer: 1,
                     questionId: 59,
                     helpText: "Вы можете использовать инструкцию if, сравнивая опционал с nil, чтобы проверить, содержит ли опционал значение. Это сравнение можно сделать с помощью оператора «равенства» (==) или оператора «неравенства» (!=). Если опционал имеет значение, он будет рассматриваться как «неравным» nil."),
            
            Question(question: ["Если мы точно уверены, что опционал имеет значение, каким наиболее быстрым образом мы можем его получить?",
                                "Каким самым быстрым образом мы можем получить значение опционала, если уверены, что оно присутствует?",
                                "Как быстро получить значение опционала, если значение точно есть?"],
                     image: "",
                     optionA: "Принудительное извлечение (!)",
                     optionB: "Внутри цикла while",
                     optionC: "Привязка опционалов",
                     optionD: "Оператор ??",
                     correctAnswer: 1,
                     questionId: 60,
                     helpText: "Если вы уверены, что опционал содержит значение, вы можете получить доступ к его значению, добавив восклицательный знак (!) в конце имени опционала. Восклицательный знак фактически говорит: «Я знаю точно, что этот опционал содержит значение, пожалуйста, используй его». Это выражение известно как Принудительное извлечение значения опционала."),
            
            
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     correctAnswer: 1,
            //                     questionId: 42,
            //                     helpText: ""),
            //
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     correctAnswer: 1,
            //                     questionId: 42,
            //                     helpText: ""),
        ]
    }
}



