
//  Created by Евгений Никитин on 12.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

// MARK:  Вопросы (id) с 1301 по 1400

class InitializationSet {
    static func getQuestions() -> [Question] {
        return [
            Question(question: ["Как \"Инициализация\" будет на английском?"],
                     image: "",
                     optionA: "Initialization",
                     optionB: "Deinitialization",
                     optionC: "Subscripts",
                     optionD: "Enumerations",
                     correctAnswer: 1,
                     questionId: 1301,
                     helpText: "Правильный ответ: Initialization."),
            
            Question(question: ["Что включает в себя процесс инициализации экземпляра?",
                                "Во время инициализации экземпляра класса или структуры происхоит это",
                                "Что происходит в момент инициализации экземпляров класса, структуры или перечисления?"],
                     image: "",
                     optionA: "Установка начальных значений",
                     optionB: "Освобождение памяти",
                     optionC: "Создание свойств хранения",
                     optionD: "Создание самого экземпляра",
                     correctAnswer: 1,
                     questionId: 1302,
                     helpText: "Инициализация - подготовительный процесс экземпляра класса, структуры или перечисления для дальнейшего использования. Этот процесс включает в себя установку начальных значений для каждого свойства хранения этого экземпляра и проведение любых настроек или инициализации, которые нужны до того, как экземпляр будет использоваться."),
            
            Question(question: ["Инициализаторы в Swift возвращают значение?",
                                "Возвращают ли инициализаторы в Swift значение?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 1303,
                     helpText: "Вы реализуете инициализацию, определяя инициализаторы, которые схожи со специальными методами, которые вызываются для создания экземпляра определенного типа. В отличии от инициализаторов в Objective-C, инициализаторы в Swift не возвращают значения."),
            
            Question(question: ["Какая основная роль инициализаторов?",
                                "Основная роль инициализаторов",
                                "У инициализаторов есть основная задача, какая?"],
                     image: "",
                     optionA: "Проверить правильность инициализации",
                     optionB: "Освобождение памяти",
                     optionC: "Создание свойств хранения",
                     optionD: "Освобождение экземпляра класса",
                     correctAnswer: 1,
                     questionId: 1304,
                     helpText: "Основная роль инициализаторов - убедиться в том, что новый экземпляр типа правильно инициализирован до того, как будет использован в первый раз."),
            
            Question(question: ["Могут ли экземпляры структуры иметь деинициализатор?",
                                "Может ли экземпляр перечисления иметь деинициализатор?",
                                "Экземпляр класса не может иметь деинициализатор, так ли это?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 1305,
                     helpText: "Экземпляры классовых типов так же могут реализовывать деинициализаторы, которые проводят любую чистку прямо перед тем, как экземпляр класса будет освобожден."),
            
            Question(question: ["Обязаны ли классы и структуры устанавливать начальные значения у всех свойств хранения, во время создания экземпляра?",
                                "Классы и структуры должны устанавливать начальные значения у всех свойств хранения во время создания класса или структуры, так ли это?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "Только экземплярам класса",
                     optionD: "Только экземплярам структуры",
                     correctAnswer: 1,
                     questionId: 1306,
                     helpText: "Классы и структуры должны устанавливать начальные значения у всех свойств хранения во время создания класса или структуры. Свойства хранения не могут быть оставлены в неопределённом состоянии."),
            
            Question(question: ["Можем ли мы присвоить значение по умолчанию для свойства хранения, как часть определения свойства?",
                                "Вы можете установить значение по умолчанию, как часть определения свойства хранения, так ли это?",
                                "Можем ли мы установить значение по умолчанию для свойства хранения, вместо использования инициализатора?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 1307,
                     helpText: "Вы можете установить начальное значение свойства внутри инициализатора или присвоить ему значение по умолчанию, как часть определения свойства."),
            
            Question(question: ["Если мы устанавливаем значение по умолчанию для свойства хранения, наблюдатель вызывается?",
                                "Когда мы устанавливаем исходное значение для свойства хранения в инициализаторе, будет вызываться наблюдатель?",
                                "Когда мы присваиваем значение по умолчанию или устанавливаем исходное значение в инициализаторе, значение устанавливается не напрямую, и мы вызываем наблюдателя свойства. Так ли это?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 1308,
                     helpText: "Когда вы присваиваете значение по умолчанию свойству хранения или устанавливаете исходное значение в инициализаторе, то значение устанавливается напрямую, без вызова наблюдателей."),
            
            Question(question: ["Каким ключевым словом вызывается инициализатор экземпляра?",
                                "Этим ключевым словом можно вызвать инициализатор экземпляра класса",
                                "Мы можем вызвать инициализатор класса с помощью этого ключевого слова"],
                     image: "",
                     optionA: "init",
                     optionB: "deinit",
                     optionC: "func",
                     optionD: "var",
                     correctAnswer: 1,
                     questionId: 1309,
                     helpText: "Инициализаторы вызываются для создания нового экземпляра конкретного типа. В самой простой своей форме инициализатор работает как метод экземпляра без параметров, написанный с помощью ключевого слова init."),
            
            Question(question: ["Предпочтительнее использовать исходные значения для свойств, если эти значения повторяются, или использовать инициализатор?",
                                "Что предпочтительнее, при повторяющихся значениях свойств, использовать инициализатор или исходные значения для свойств хранения?"],
                     image: "",
                     optionA: "Исходные значения",
                     optionB: "Инициализатор",
                     optionC: "Без разницы",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 1310,
                     helpText: "Если свойство каждый раз берет одно и то же исходное значение, то лучше указать это значение, в качестве значения по умолчанию, чем каждый раз устанавливать его в инициализаторе. Конечный результат такой же, но значение по умолчанию связывает инициализацию свойства ближе к своему объявлению. Так делают, чтобы оставить инициализаторы в более чистой и краткой форме, и это позволяет вам вывести тип свойства из его значения по умолчанию."),
            
            Question(question: ["Являются ли данные структуры равнозначными?",
                                "Эти структуры эквивалентны?"],
                     image: "Initialization11",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 1311,
                     helpText: "Вы можете написать структуру FahrenheitSecond в более простой форме, указав значение по умолчанию для свойства temperature, в месте его объявления в инициализаторе."),
            
            Question(question: ["Могут ли инициализаторы иметь входящие параметры?",
                                "Вы можете показать параметры инициализации как часть определения инициализатора, так ли это?",
                                "Параметры инициализатора имеют те же возможности и синтаксис, как и параметры функции или метода?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 1312,
                     helpText: "Вы можете показать параметры инициализации как часть определения инициализатора, для определения типов и имен значений, которые настраивают процесс инициализации. Параметры инициализации имеют те же возможности и синтаксис как и параметры функции или метода."),
            
            Question(question: ["Может ли класс иметь два пользовательских инициализатора?",
                                "Может ли структура иметь три пользовательских инициализатора?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 1313,
                     helpText: "Правильный ответ: Да. Классы и структуры могут иметь необходимое количество пользовательских инициализаторов. Главное, чтобы ваши иниализаторы имели разные внешние имена."),
            
            Question(question: ["Параметры инициализации могут иметь как внешнее, так и локальное имя одновременно. Так ли это?",
                                "Параметры инициализации могут иметь локальные имена и внешние имена, это так?",
                                "У параметров инициализации, как и у параметров функций или методов, есть локальные и внешние имена, это так?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "Только внешнее имя",
                     optionD: "Только локальное имя",
                     correctAnswer: 1,
                     questionId: 1314,
                     helpText: "Как и в случае с параметрами функций или методов, параметры инициализации могут иметь локальные имена для использования внутри тела инициализатора и внешние для использования при вызове инициализатора."),
            
            Question(question: ["Может ли инициализатор иметь свое имя?",
                                "Имеет ли инициализатор имя как методы или функции?",
                                "Есть ли у инициализаторов имена до круглых скобок?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 1315,
                     helpText: "Инициализаторы не имеют своего имени до круглых скобок, как это имеют методы или функции. Поэтому имена и типы параметров инициализатора играют важную роль в определении того, какой инициализатор и где может быть использован."),
            
            Question(question: ["Если вы не укажите свое внешнее имя для параметра инициализатора, что произойдет?",
                                "Если вы не указали внешнее имя для параметра инициализатора, произойдет это"],
                     image: "",
                     optionA: "Имя предоставляется автоматически",
                     optionB: "Не будет внешнего имени",
                     optionC: "Столкнемся с ошибкой",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 1316,
                     helpText: "Swift предоставляет автоматические внешние имена для каждого параметра, если вы, конечно, не укажите свое внешнее имя."),
            
            Question(question: ["Если у параметра инициализатора определено внешнее имя, можем ли мы вызвать его, не указывая это имя?",
                                "Можем ли мы вызвать инициализатор без внешних имен параметров, если они определены?"],
                     image: "",
                     optionA: "Получим ошибку компиляции",
                     optionB: "Да, можем",
                     optionC: "На наше усмотрение",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 1317,
                     helpText: "Обратите внимание, что невозможно вызвать инициализатор без использования внешних имен. Внешние имена обязательно должны быть использованы в инициализаторе, если они определены, если пропустить их, то выскочит ошибка компиляции."),
            
            Question(question: ["Если при вызове инициализатора вы не хотите использовать внешние имена для параметров инициализации, какой символ мы должны поставить до локального имени?",
                                "Какой символ мы можем поставить до локального имена параметра инициализатора, чтобы при его вызове нам не пришлось указывать внешнее имя?"],
                     image: "",
                     optionA: "Нижнее подчеркивание (_)",
                     optionB: "Двоеточие (:)",
                     optionC: "Тире (-)",
                     optionD: "Амперсанд (&)",
                     correctAnswer: 1,
                     questionId: 1318,
                     helpText: "Если вы не хотите использовать внешние имена для параметров инициализации, напишите подчеркивание (_) вместо явного указания внешнего имени для этого параметра, чтобы переопределить поведение по умолчанию."),
            
            Question(question: ["Если ваш пользовательский тип имеет свойство, которое логически имеет “отсутствие значения, какой тип для этого сойства необходимо использовать?"],
                     image: "",
                     optionA: "Опциональный",
                     optionB: "nil",
                     optionC: "Int",
                     optionD: "String",
                     correctAnswer: 1,
                     questionId: 1319,
                     helpText: "Если ваш пользовательский тип имеет свойство, которое логически имеет “отсутствие значения”, возможно потому, что его значение не может быть установлено во время инициализации или потому, что ему разрешается иметь “отсутствие значения” в какой-либо точке кода, то такое свойство нужно объявить с опциональным типом. Свойства опционального типа автоматически инициализируются со значением nil, указывая на то, что значение стремится иметь значение “пока что отсутствие значение” на этапе инициализации."),
            
            Question(question: ["Можем ли мы изменять постоянное свойство хранения, после того, как мы просвоили значение в процессе инициализации?",
                                "Когда во время инициализации мы присвоили значение постоянному свойству хранения, можем ли мы его дальше изменять?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 1320,
                     helpText: "Вы можете присвоить значения постоянных (когда свойство константа) свойств в любой точке вашего процесса инициализации. Как только для свойства константы присваивается значение, оно не может быть далее изменено."),
            
            Question(question: ["В какой момент мы можем изменять постоянное свойство хранения у экземпляра класса?",
                                "Когда вы можете изменить постоянное свойство хранения у экземпляра?"],
                     image: "",
                     optionA: "Во время инициализации",
                     optionB: "Никогда",
                     optionC: "В любой момент",
                     optionD: "В подклассе",
                     correctAnswer: 1,
                     questionId: 1321,
                     helpText: "В экземплярах класса постоянное свойство может быть изменено только во время инициализации класса, в котором оно представлено. Оно не может быть изменено подклассом."),
            
            Question(question: ["Может ли подкласс изменять проинициализированное постоянное свойство хренения суперкласса?",
                                "Мы можем изменить постоянно свойство хранения суперкласса в экземпляре подкласса, так ли это?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 1322,
                     helpText: "В экземплярах класса постоянное свойство может быть изменено только во время инициализации класса, в котором оно представлено. Оно не может быть изменено подклассом."),
            
            Question(question: ["Если у всех свойств структуры есть исходное значение, и нет инициализатора, чем мы можем воспользоваться, чтобы создать новый экземпляр?",
                                "У базового класса, который имеет значение по умолчанию для всех его свойств и не имеет ни одного инициализатора, есть это, и с помощью этого можно создавать новые экземпляры"],
                     image: "",
                     optionA: "Дефолтный инициализатор",
                     optionB: "Стартовый инициализатор",
                     optionC: "Деинициализатор",
                     optionD: "Стартер",
                     correctAnswer: 1,
                     questionId: 1323,
                     helpText: "Swift предоставляет дефолтный инициализатор для любой структуры или базового класса, который имеет значение по умолчанию для всех его свойств и не имеет ни одного инициализатора. Дефолтный инициализатор просто создает новый экземпляр со всеми его свойствами с уже присвоенными значениями по умолчанию."),
            
            Question(question: ["Что мы получим после компиляции?",
                                "Какой результат мы получим после запуска данного кода?"],
                     image: "Initialization24",
                     optionA: "Экземпляр ShoppingListItem",
                     optionB: "Ошибку компиляции",
                     optionC: "Ошибку инициализации",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 1324,
                     helpText: "Так как все свойства класса ShoppingListItem имеют значения по умолчанию и так как этот класс не имеет суперкласса, то ShoppingListItem автоматически получает реализацию дефолтного инициализатора, который создает новый экземпляр со всеми свойствами с уже присвоенными значениями по умолчанию. (Свойство name - свойство опционального типа String, значит значение по умолчанию равно nil). В примере выше используется дефолтный инициализатор для класса ShoppingListItem для создания нового экземпляра. Синтаксис дефолтного инициализатора в нашем случае выглядит как ShoppingListItem(), что присваивается переменной item."),
            
            Question(question: ["Сокращенный способ инициализировать свойства члена нового экземпляра структуры",
                                "При инициализации нового экземпляра структуры, мы можем воспользоваться этим инициализатором"],
                     image: "",
                     optionA: "Почленный инициализатор",
                     optionB: "Дефолтный инициализатор",
                     optionC: "Запрашиваемый инициализатор",
                     optionD: "Деинициализатор",
                     correctAnswer: 1,
                     questionId: 1325,
                     helpText: "Почленный инициализатор - сокращенный способ инициализировать свойства члена нового экземпляра структуры. Начальные значения для свойств нового экземпляра могут быть переданы в почленный инициализатор по имени."),
            
            Question(question: ["Могут ли иниализаторы вызывать другие инициализаторы?",
                                "Могут ли инициализаторы вызывать другие инициализаторы для инициализации части экземпляра?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 1326,
                     helpText: "Инициализаторы могут вызывать другие инициализаторы для инициализации части экземпляра. Этот процесс называется как делегирование инициализатора. Он позволяет избегать дублирования кода в разных инициализаторах."),
            
            Question(question: ["Для типов значения и ссылочных типов существуют разные правила для делегирования инициализатора, так ли это?",
                                "Наследование у классов провоцирует другое поведение при делегировании инициализатора, так ли это?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 1327,
                     helpText: "Правила того, как работает делегирование инициализатора и для каких форм делегирования это возможно, для типов значений и ссылочных типов разные. Типы значений (структуры и перечисления) не поддерживают наследование, так что их процесс делегирования инициализатора сравнительно прост, потому что они только могут делегировать другому инициализатору то, что предоставляют сами. Классы, однако, могут наследовать от других классов. Это значит, что у классов есть дополнительная ответственность за проверку наличия корректных значений у каждого унаследованного свойства хранения класса."),
            
            Question(question: ["Если мы определили пользовательский инициализатор для типа значений, будем ли мы иметь доступ к дефолтному или почленному инициализатору?",
                                "Будем ли мы иметь доступ к дефолтному инициализатору, если мы определили пользовательский инициализатор для типа значений (структуры или перечисления)?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     correctAnswer: 1,
                     questionId: 1328,
                     helpText: "Обратите внимание, что если вы определите пользовательский инициализатор для типов значений, то вы больше не будете иметь доступа к дефолтному инициализатору (или почленному инициализатору, если это структура) для этого типа. Такое ограничение предотвращает ситуацию, в которой настройка важного дополнения в более сложном инициализаторе может быть пропущена при случайном использовании автоматического инициализатора."),
            
            Question(question: ["Где мы должны написать пользовательский инициализатор, чтобы иметь возможность продолжать пользоваться дефолтным инициализатором или почленным инициализатором типа значения?",
                                "Чтобы иметь возомжность пользоваться дефолтным инициализатором типа значения, но так же сделать свой пользовательский инициализатор, мы должны написать его там"],
                     image: "",
                     optionA: "В расширении типа",
                     optionB: "Внутри структуры",
                     optionC: "В дефолтном инициализаторе",
                     optionD: "Не имеет значения",
                     correctAnswer: 1,
                     questionId: 1329,
                     helpText: "Если вы хотите, чтобы ваш пользовательский тип значения имел возможность быть инициализированным дефолтным инициализатором или почленным инициализатором, или вашим пользовательским инициализатором, то вам нужно написать свой пользовательский инициализатор в расширении вашего типа, чем как часть реализации типа значения."),
            
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//                     correctAnswer: 1,
//                     questionId: 1330,
//                     helpText: ""),
//            
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//                     correctAnswer: 1,
//                     questionId: 1331,
//                     helpText: ""),
//            
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//                     correctAnswer: 1,
//                     questionId: 1332,
//                     helpText: ""),
//            
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//                     correctAnswer: 1,
//                     questionId: 1333,
//                     helpText: ""),
//            
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//                     correctAnswer: 1,
//                     questionId: 1334,
//                     helpText: ""),
//            
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//                     correctAnswer: 1,
//                     questionId: 1335,
//                     helpText: ""),
//            
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//                     correctAnswer: 1,
//                     questionId: 1336,
//                     helpText: ""),
//            
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//                     correctAnswer: 1,
//                     questionId: 1337,
//                     helpText: ""),
//            
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//                     correctAnswer: 1,
//                     questionId: 1338,
//                     helpText: ""),
//            
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//                     correctAnswer: 1,
//                     questionId: 1339,
//                     helpText: ""),
//            
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//                     correctAnswer: 1,
//                     questionId: 1340,
//                     helpText: ""),
//            
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//                     correctAnswer: 1,
//                     questionId: 1341,
//                     helpText: ""),
        ]
    }
}
